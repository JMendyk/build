\section{Build systems, concretely}\label{sec-implementations}

In the previous sections we discussed the types of build systems, and how they
can be broken down. But these divisions were not obvious to us, and only by
concretely implementing and refactoring each build system did we determine the
underlying commonalities. In this section we share some of the code that got us
there.

% Our code comprises a framework, utility functions implementing the
% various dependency orderings as per~\S\ref{sec-dependency-orderings}, and
% actual implementations.

% \subsection{Framework}

% todo{SLPJ}{I think this entire section, including the mysterious M, can be deleted.  Or is
% there anything that remains?}

% \begin{figure}
% \begin{minted}{haskell}
% type M i k v r = State (i, k -> v, ...) r
% runM :: Default i => M i k v a -> Maybe i -> (k -> v) -> (i, k -> v)

% getStore :: k -> M i k v v
% putStore :: k -> v -> M i k v ()
% getInfo :: M i k v i
% modifyInfo :: (i -> i) -> M i k v ()
% \end{minted}
% Note: we have omitted the context on \hs{k}, things like \hs{Eq} (to implement the store).
% \caption{API with which to implement build systems}
% \label{fig-M-api}
% \end{figure}

% We use \hs{runM} to switch between the pure world of \hs{Build} and a state monad \hs{M} which lets us more precisely express the ideas behind the build system without threading the state manually - the types of important operations are given in Figure~\ref{fig-M-api}. We provide functions like \hs{getStore} to load from the store and \hs{putStore} to write to the store. We'll introduce the other functions in in the monad \hs{M} as we need them while exploring the build systems.

\subsection{\Make}\label{sec-implementation-make}

\Make processes keys in a linear order based on a topological sort
(see~\S\ref{sec-concurrency} for parallel \Make). For each key, it builds it if
it is older than any of its dependencies. To express \Make in our framework,
we capture the persistent information it stores by a pair
\hs{(@@modTime,}~\hs{now)} comprising the \emph{file modification time} function
\hs{modTime}~\hs{::}~\hs{k}~\hs{->}~\hs{Time} and the \emph{current time} \hs{now}.
Setting aside the explicit manipulation of file modification times, which in
reality is taken care of by the file system, the \hs{make} build system defined
below captures the essence of \Make in a clear and precise manner.

\begin{minted}[xleftmargin=10pt]{haskell}
type Time = Integer
type MakeInfo k = (k -> Time, Time)
\end{minted}
\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
make :: Eq k => Build Applicative (MakeInfo k) k v
make = topological process
  where
    process key deps act = do
        (modTime, now) <- getInfo <$> get
        let dirty = or [ modTime dep > modTime key | dep <- deps ]
        when dirty $ do
            v <- act
            let newModTime k = if k == key then now else modTime k
            modify $ \s -> putInfo (putValue s key v) (newModTime, now + 1)
\end{minted}

\noindent
The helper function \hs{topological}, which we describe below, calls
\hs{process} on every \hs{key} in the topological order, providing the list of
its dependencies \hs{deps} and the action \hs{act} to compute the resulting
value if it needs to be rebuilt. To determine if the \hs{key} is \hs{dirty},
\hs{process} compares its modification time with those of its dependencies. If
the \hs{key} needs to be rebuilt, the action \hs{act} is executed and the
obtained result is stored, along with an updated file modification timestamp.

The implementation of \hs{topological} encodes the dependency strategy that
\Make has chosen to use. The function itself is defined as:

\vspace{1mm}
\begin{minted}{haskell}
topological :: Eq@\,\blk{k}@ => (k -> [k] -> State@\,@(Store i k v)@\,\blk{v}@ -> State@\,@(Store i k v)@\,@(@@))
            -> Build Applicative i k v
topological process task key = execState $ forM_ chain $ \k -> do
    let fetch k = do store <- get; return (getValue store k)
    case task fetch k of
        Nothing  -> return ()
        Just act -> process k (deps k) act
  where
    deps  = dependencies task
    chain = topologicalSort deps (transitiveClosure deps key)
\end{minted}
\vspace{1mm}

\noindent
The \hs{where} clause corresponds to the pre-processing step, which uses the
function \hs{dependencies}, defined in~\S\ref{sec-deps}, to extract static
dependencies from the provided applicative \hs{task}. We compute the linear
processing \hs{chain} by taking the \hs{transitiveClosure} of \hs{key}'s
dependencies, and performing the \hs{topologicalSort} of the result. We omit
implementation of textbook graph algorithms \hs{transitiveClosure} and
\hs{topologicalSort}~\cite{cormen2001introduction}.

The \hs{chain} is processed in the \hs{State} monad, with each non-input key
\hs{k} in the chain passed to the provided \hs{process} function, along with
\hs{k}'s dependencies and the action \hs{act}, which when executed recomputes
the \hs{k}'s value by fetching its dependencies from the store.

Note that \hs{dependencies} is only defined for applicative tasks, which is what
restricts \Make to static dependencies, as reflected in the
type~\hs{Build}~\hs{Applicative}. Moreover, any other build system following
the same \hs{topological} approach will also inherit the same restriction.

\subsection{\Excel}\label{sec-implementation-excel}

\todo{AM}{I might do some simplification of this tomorrow. Neil: I guess it's best
for you to focus on nailing traces and associated \Shake and \Bazel sections.}

As a programming exercise, \Excel is the most challenging, due to the complicated reordering dependency scheme, which requires retrying out-of-order operations. The complete implementation is:

\begin{minted}{haskell}
excel :: Eq v => Build Monad (Changed k v, [k]) k v
excel = withChanged $ reordering $ \k dk _ act -> do
    dirty <- getChanged k ||^ maybe (return True) (anyM getChanged) dk
    if not dirty
       then return Nothing
       else act >>= \case
              Left e -> return $ Just e
              Right (_, v) -> do putStore k v
                                 return Nothing
\end{minted}

We use the helper function \hs{reordering} which provides the key to build (\hs{k}), the dependencies of \hs{k} (\hs{dk}) and an action to build \hs{k} (\hs{act}). The dirty check is the same as \hs{makeDirtyBit}, with the added complication that because the \hs{Task} is monadic it may not be possible to statically get a list of dependencies - if \hs{dk} is \hs{Nothing} then the action uses the monadic power and we conservatively rebuild anyway. If the check determines that the key is dirty, and needs rebuilding, we run \hs{act}, giving two possibilities:

\begin{enumerate}
\item The key cannot be built at this time because it depends on a key which has not yet been computed - and thus \hs{act} returns \hs{Left e}, where \hs{e} is the key that we are waiting for. In response we return \hs{e} as the result of step - asking \hs{reordering} to requeue this key after \hs{e}.
\item The key builds successfully, so we store it and return \hs{Nothing} to indicate \hs{reordering} can move on to the next key.
\end{enumerate}

The astute reader may notice that \hs{reordering} supplies extra information that is ignored with \hs{_} patterns. While not required for \Excel, we have implemented build systems using \hs{reordering} which use verifying and constructive traces, effectively turning \Excel into a cloud build system and ensuring \hs{reordering} is not overly fitted to \Excel alone (additional implementations available in the supplementary material). The definition of \hs{reordering} is:

\begin{minted}{haskell}
reordering
    :: (m ~ M (i, [k]) k v, Default i)
    => (k -> Maybe [k] -> (k -> m (Maybe v)) -> m (Either k ([k], v)) -> m (Maybe k))
    -> Build Monad (i, [k]) k v
\end{minted}

Dynamic requires a function that takes takes 4 arguments (we use \hs{m} to elide \hs{M (i, [k]) k v} from all the signatures):

\begin{enumerate}
\item \hs{k} - the key that is being built.
\item \hs{Maybe [k]} - the list of dependencies, or \hs{Nothing} if the step makes use of monadic dependencies. Note that above if a step is truly monadic it is always rebuilt. In the case of spreadsheets such steps are very rare, so a very conservative approximation can be used.\footnote{In truth, many spreadsheets take the alternative approximation of always assuming monadic steps \textit{did not} change - trading correctness for performance.}
\item \hs{k -> m (Maybe v)} - a function that looks up a key - it returns \hs{Nothing} if that key has not yet been built (and thus there is a dependency violation).
\item \hs{m (Either k ([k], v))} - an action to produce either the \hs{k} which is required but not yet computed (the reason you fail your dependency order check), or a list of the keys used and value produced.
\item It returns \hs{m (Maybe k)}, with a \hs{Nothing} to indicate the the build succeeded, or \hs{Just k} to indicate that the given key \hs{k} has not been built, and thus this key should be moved after \hs{k}.
\end{enumerate}

The implementation of \hs{dynamic} is 15 lines, but is substantially complicated by the requirement to ensure newly discovered keys are added to the list - something an actual spreadsheet with a fixed universe of cells need not do.

\subsection{\Shake}\label{sec-implementation-shake}

\todo{NM}{Remove the intermediate \hs{M} layer, as done in \Make.}

The Shake approach for dependency tracking involves recording traces and verifying them. Using the \hs{Trace} type defined in \ref{sec-verifying-traces} we can implement:

\begin{minted}{haskell}
shake :: Hashable v => Build Monad [Trace k v] k v
shake = recursive $ \k _ fetch act -> do
    poss <- traceMatch (\k v -> (==) v . getHash <$> fetch k) k =<< getInfo
    h <- getStoreHash k
    when (h `notElem` poss) $ do
        (dk, v) <- act
        putStore k v
        dh <- mapM getStoreHash dk
        modifyInfo (Trace k (zip dk dh) (getHash v) :)
\end{minted}

This implementation uses the \hs{recursive} function which requires a function which gets the key to build (\hs{k}), a way to fetch the result of a dependency (\hs{fetch}), and a way to build \hs{k} (\hs{act}). The code first looks up the traces that match the current situation, creating a list of possible results as \hs{poss}, using the helper \hs{traceMatch}. We check if the current value for the key is one of the possible results, and it not, build the key and store it in the trace. We can implement \hs{traceMatch}, which is used in all build systems working with \hs{Trace}, as:

\begin{minted}{haskell}
traceMatch :: (Monad m, Eq k) => (k -> Hash v -> m Bool) -> k -> [Trace k v] -> m [Hash v]
traceMatch check k ts = mapMaybeM f ts
    where f (Trace k2 dkv v) = do
                b <- return (k == k2) &&^ allM (uncurry check) dkv
                return $ if b then Just v else Nothing
\end{minted}

The function \hs{traceMatch} requires a way to check a dependency, and the key, and the traces. We return the \hs{result} field from all traces where the key and dependencies match. We define the recursive combinator as:

\begin{minted}{haskell}
recursive
    :: (m ~ M i k v, Default i)
    => (k -> Maybe [k] -> (k -> m v) -> m ([k], v) -> m ())
    -> Build Monad i k v
recursive step compute = runM . ensure
    where
        ensure k = do
            let fetch x = ensure x >> getStore x
            done <- getTemp
            when (k `Set.notMember` done) $ do
                modifyTemp $ Set.insert k set
                case track compute fetch k of
                    Nothing -> return ()
                    Just act -> step k (getDependenciesMaybe compute k) fetch act
\end{minted}

The required \hs{step} function gets given the \hs{k} to build, the dependencies as \hs{Maybe [k]} (where they are \hs{Nothing} if the rule is truly monadic), a function to demand the result of a dependent key, and a function to compute the current value and return the actual dependencies. To ensure each file is only visited once in a single execution a piece of temporary state is used with \hs{getTemp} and \hs{modifyTemp} to record which files were visited - this state is not persisted to the \hs{i} info parameter and is reset on each fresh execution of \hs{M}.

\subsection{\Bazel}\label{sec-implementation-bazel}

\todo{NM}{Remove the intermediate \hs{M} layer, as done in \Make.}

Now we have seen the three dependency schemes, we can directly reuse \hs{topological} to define \Bazel. Furthermore, as \Bazel is a tracing build system, we can reuse \hs{Trace} and \hs{traceMatch}, as part of the \hs{Traces} type. We define \Bazel as:

\begin{minted}{haskell}
bazel :: Hashable v => Build Applicative (Traces k v) k v
bazel = topological $ \k dk act -> do
    poss <- traceMatch (\k v -> (== v) <$> getStoreHash k) k . traces =<< getInfo
    if null poss then do
        v <- act
        dh <- mapM getStoreHash dk
        modifyInfo $ \i -> i
            {traces = Trace k (zip dk dh) (getHash v) : traces i
            ,contents = Map.insert (getHash v) v $ contents i}
        putStore k v
    else do
        h <- getStoreHash k
        when (h `notElem` poss) $
            putStore k . (Map.! head poss) . contents =<< getInfo
\end{minted}

We execute keys in a topological order. For each key we first get a list of the traces that match. If there are none we rebuild and record the trace, much like \Shake, but also recording the value of the result. If there are some matching traces, and the current value of \hs{k} is not compatible, we grab the first possibility and grab its value from \hs{contents}.

\subsection{Cloud \Shake}\label{sec-implementation-cloud-shake}

\todo{NM}{Remove the intermediate \hs{M} layer, as done in \Make.}

Using the abstractions and approaches built thus far, we have shown how to combine dependency scheme and change approach to reproduce existing build systems. In the attached materials we have implemented 9 build systems corresponding to all three dependency schemes, matched with all three change approaches. To us, the most interesting build system as yet unavailable would matching recursive ordering with constructive traces - providing a cloud-capable build system with minimality, cut-off and monadic dependencies. Using our framework it is possible to define and test such a system:

\begin{minted}{haskell}
cloudShake :: Hashable v => Build Monad (Traces k v) k v
cloudShake = recursive $ \k _ fetch act -> do
    poss <- traceMatch (\k v -> (== v) . getHash <$> fetch k) k . traces =<< getInfo
    if null poss then do
        (dk, v) <- act
        dh <- mapM getStoreHash dk
        modifyInfo $ \i -> i
            {traces = Trace k (zip dk dh) (getHash v) : traces i
            ,contents = Map.insert (getHash v) v $ contents i}
        putStore k v
    else do
        now <- getStoreHash k
        when (now `notElem` poss) $
            putStore k . (Map.! head poss) . contents =<< getInfo
\end{minted}

The differences from \hs{bazel} are minor - the dependency scheme has changed from \hs{topological} to \hs{recursive}, and thus the dependency keys \hs{dk} are captured from the action rather than in advance, and the checking calls \hs{fetch} to get the result instead of accessing the store directly. We believe this accurately captures and can be used to reason about how to make \Shake work with a cloud-based cache -- a challenge we intend to attempt in the future.

\subsection{Smarter \hs{[Trace]} Structures}\label{sec-smart-traces}
\todo{NM}{Remove the intermediate \hs{M} layer, as done in \Make.}

In the examples above, we have used \hs{[Trace]} to capture a list of traces stored in the info field, which accurately models the data and operations. However, using a list necessarily means that finding the right trace takes $O(n)$. For each of the \hs{Trace} based systems it is possible to devise a smarter representation, which we sketch below. Note that these implementations do not avoid calls to \hs{compute}, merely overheads in the build system itself.

\begin{enumerate}
\item Any system using verifying traces, e.g. \Shake, is unlikely to see significant benefit from storing more than one \hs{Trace} per key\footnote{There is a small chance of a benefit if the dependencies change but the result does not, and then the dependencies change back to what they were before.}. Therefore, such systems can store \hs{Map k (Trace k v)}, where the initial \hs{k} is the \hs{key} field of \hs{Trace}.
\item Any system using \hs{Applicative} dependencies can omit the dependency keys from the \hs{Trace} as they can be recovered from the \hs{key} field.
\item Any \hs{Applicative} system storing constructive traces, e.g. \Bazel, can index directly from the key and results to the output result - i.e. \hs{Map (k, [Hash v]) (Hash v)}. Importantly, assuming the traces are stored on a central server, the client can compute the key and the hashes of its dependencies, then make a single call to the server to retrieve the result hash. In this formulation we have removed the possibility for a single key/dependency state to map to multiple different hashes, e.g. on a non-deterministic build - something \Bazel already prohibits which is discussed more in \S\ref{sec-non-determinism}.
\item Finally, a \hs{Monad} system with constructive traces can be efficiently encoded as \hs{Map k (Choice k v)}, assuming a definition of \hs{Choice} as:
\begin{minted}{haskell}
data Choice k v = Choice k (Map (Hash v) Choice)
                | Result (Hash v)
\end{minted}
Here the \hs{Choice} effectively encodes a tree, asking successive questions about keys, and taking different branches based on the resulting value, until it reaches a final result. Implementing this structure over client-server communication requires either a chatty interface with lots of round-trips per \hs{Choice} step, or sending over a part of the tree that is not subsequently explored.
\end{enumerate}

As an aside we note that the optimal cloud structure for applicative and monadic constructive systems has a resemblance to the free dependency structures described in \S\ref{sec-free-build}.
