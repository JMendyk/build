\section{Build systems, concretely}\label{sec-implementations}

In the previous sections we discussed the types of build systems, and how they
can be broken down into two main components: a scheduler and a rebuilder. This
decomposition was not obvious to us, and only by concretely implementing and
refactoring each build system did we determine the underlying commonalities.
In this section we share some of the code that got us there.

\subsection{\Make}\label{sec-implementation-make}

\begin{figure}
\begin{minted}[fontsize=\small]{haskell}
-- Make build system
make :: Ord k => Build Applicative (MakeInfo k) k v
make = topological modTimeRebuilder
\end{minted}
\vspace{0mm}
\begin{minted}[fontsize=\small]{haskell}
-- Build information: current time and file modification times
type Time       = Integer
type MakeInfo k = (Time, Map k Time)
\end{minted}
\vspace{0mm}
\begin{minted}[fontsize=\small]{haskell}
-- A task rebuilder based on file modification times
modTimeRebuilder :: Ord k => Rebuilder Applicative (MakeInfo k) k v
modTimeRebuilder key value task = Task $ \fetch -> do
    (now, modTime) <- get
    let dirty = case Map.lookup key modTime of
            Nothing -> True
            time -> any (\d -> Map.lookup d modTime > time) (dependencies task)
    if not dirty then return value else do
        put (now + 1, Map.insert key now modTime)
        run task fetch
\end{minted}
\vspace{0mm}
\begin{minted}[fontsize=\small]{haskell}
-- A topological task scheduler
topological :: Ord k => Rebuilder Applicative i k v -> Build Applicative i k v
topological rebuilder tasks target = execState $ forM_ order $ \key -> case tasks key of
    Nothing   -> return ()
    Just task -> do
        store <- get
        let newTask :: Task (MonadState i) k v
            newTask = rebuilder key (getValue key store) task
            fetch :: k -> State i v
            fetch k = pure (getValue k store)
            (newValue, newInfo) = runState (run newTask fetch) (getInfo store)
        modify $ putInfo newInfo . putValue key newValue
  where
    deps k = case tasks k of { Nothing -> [@@]; Just task -> dependencies task }
    order  = case topSort (reachable deps target) of
        Nothing -> error "Cannot build tasks with cyclic dependencies"
        Just xs -> xs
\end{minted}
\vspace{0mm}
\begin{minted}[fontsize=\small]{haskell}
-- Standard graph algorithms (implementation omitted)
reachable :: Ord k => (k -> [k]) -> k -> Graph k
topSort   :: Ord k => Graph k -> Maybe [k]
\end{minted}
\vspace{-2mm}
\caption{An implementation of \Make using our framework.}\label{fig-make-implementation}
\vspace{-4mm}
\end{figure}

An implementation of \Make using our framework is shown in
Fig.~\ref{fig-make-implementation}. The top-level definition
\hs{make}~\hs{=}~\hs{topological}~\hs{modTimeRebuilder} is a direct translation
of the scheduler-rebuilder decomposition in Table~\ref{tab-build-systems}. Below
we describe both components, starting with \hs{modTimeRebuilder}.

We capture persistent build information that \Make stores by the pair
\hs{(@@now,}~\hs{modTime)} comprising the \emph{current time} \hs{now} and the
map \hs{modTime}~\hs{::}~\hs{Map}~\hs{k}~\hs{Time} that stores \emph{file
modification times}. The rebuilder receives three arguments: a \hs{key}, its
current \hs{value}, and the \hs{task} of type
\hs{Task}~\hs{Applicative}~\hs{k}~\hs{v} that can be used to rebuild the
\hs{key} if necessary. The rebuilder returns a modified monadic task of type
\hs{Task}~\hs{(@@MonadState}~\hs{(@@MakeInfo}~\hs{k))}~\hs{k}~\hs{v} that has
access to the build information and uses it to decide whether to return the
current \hs{value} as is or rebuild the \hs{key} if it is \hs{dirty}, i.e.
if it is older than any of its dependencies\footnote{Since the \hs{task} is
applicative we can statically find its dependencies using the function
\hs{dependencies} defined in~\S\ref{sec-deps}.} or has never been built before
(in which case \hs{modTime} has no entry for it). Note that in our model we
update the current time and file modification time whenever the \hs{key} is
rebuilt, which in reality is taken care of by the file system.

\Make's scheduler processes keys in a linear \hs{order} based on a
\hs{topological} sort of the statically known dependency graph
(see~\S\ref{sec-parallelism} for parallel \Make). Our definition in
Fig.~\ref{fig-make-implementation} is polymorphic with respect to the type of
build information \hs{i} and is therefore compatible with any applicative
\hs{rebuilder}. The scheduler calls the supplied \hs{rebuilder} on every
\hs{key} in the \hs{order}, and runs the obtained \hs{newTask} to compute the
\hs{newValue} and updated build information \hs{newInfo}, which are subsequently
written to the store. The computation runs in the
\hs{State}~\hs{(@@Store}~\hs{i}~\hs{k}~\hs{v)} monad, similar to the \hs{busy}
build system (\S\ref{sec-general-build}), however since \hs{newTask} has access
only to the \hs{i} part of the \hs{Store}~\hs{i}~\hs{k}~\hs{v}, we need to use
\hs{runState} to execute it. The \hs{newTask} finds values of the \hs{key}'s
dependencies via the \hs{fetch} callback that directly reads the \hs{store}.

The \hs{where} clause corresponds to the pre-processing stage, which uses the
function \hs{dependencies}, defined in~\S\ref{sec-deps}, to extract static
dependencies from the provided applicative \hs{task}. We compute the linear
processing \hs{order} by constructing the graph of keys \hs{reachable} from the
\hs{target} via dependencies, and performing the topological sort of the result.
We omit implementation of textbook graph algorithms
\hs{reachable} and \hs{topSort}, e.g. see~\cite{cormen2001introduction}.

Note that \hs{dependencies} is only defined for applicative tasks, which is what
restricts \Make to static dependencies, as reflected in the
type~\hs{Build}~\hs{Applicative}. Moreover, any other build system using
the same \hs{topological} scheduler will also inherit the same restriction.

\subsection{\Excel}\label{sec-implementation-excel}

Fig.~\ref{fig-excel-implementation} shows an implementation of \Excel in our
framework as a composition of the \hs{restarting} scheduler and an
\hs{approximateRebuilder}.

\Excel's persistently stored build information is a triple:

\begin{itemize}
    \item A set of dirty keys \hs{Set}~\hs{k}, i.e. all cells whose contents
          has changed since the previous build, including cells that contain
          input values as well as formulas.
    \item A map \hs{Map}~\hs{k}~\hs{[@@k]} that stores known upper bounds of
          dependencies. If there is an entry for a key, it is a conservative
          approximation of its dependencies (e.g. the dependencies of the
          formula \cmd{IF(C1=1,B2,A2)} can be approximated by the list
          \hs{[}\cmd{C1}\hs{,}\cmd{B2}\hs{,}\cmd{A2}\hs{]}). Otherwise, there is
          no upper bound (e.g. the key uses an \cmd{INDIRECT} reference) and
          the key is assumed to be dirty.
    \item A calculation \hs{Chain} recorded in the previous build
          (\S\ref{sec-background-excel}), represented by a list of keys \hs{[@@k]}.
\end{itemize}

The \hs{approximateRebuilder} uses the first two elements of the above triple
to decide whether a given \hs{key} is \hs{dirty} and hence needs to be rebuilt.
The logic is similar to that of \Make's \hs{modTimeRebuilder}, but instead of
relying on file modification times, \Excel stores the information about dirty
keys more directly. Furthermore, \Excel's dependency approximation makes it
possible to build tasks with dynamic dependencies: a \hs{key} is declared
\hs{dirty} if any of its approximate dependencies is in the \hs{dirtyKeys} set,
or if there is no known upper bound on dependencies, i.e. if the lookup in the
map \hs{deps}~\hs{::}~\hs{Map}~\hs{k}~\hs{[@@k]} fails. Note that when a
\hs{key} is rebuilt it is added to the \hs{dirtyKeys} set to trigger further
rebuilds.

\Excel's \hs{restarting} scheduler processes keys in the order specified by the
calculation \hs{chain}, constructing a \hs{newChain} for the next build and
maintaining a set of keys \hs{done} that have already been processed. For each
non-input \hs{key}, the scheduler tries to rebuild it using a partial \hs{fetch}
callback that returns \hs{Either}~\hs{k}~\hs{v} instead of \hs{v}. The callback
is defined to fail with \hs{Left}~\hs{dep} when asked for the value of a
dependency \hs{dep} that has not yet been processed (and hence may potentially
be dirty); otherwise it returns the current value of the dependency in the
\hs{store}.

After the \hs{newTask} is executed with \hs{runState} there are two cases to
consider:

\begin{itemize}
    \item The \hs{newTask} has failed, because one of its dependencies \hs{dep}
    has not yet been processed. This indicates that the calculation \hs{chain}
    from the previous build is incorrect and needs to be adjusted by making sure
    it contains \hs{dep} and moving the \hs{key} to the end, so that its build
    can be restarted after the \hs{dep} is ready.
    \item The \hs{newTask} succeeded. The resulting \hs{newValue} and
    \hs{newInto} are written to the store, and \Excel continues to build the
    \hs{chain} after marking the \hs{key} as \hs{done}.
\end{itemize}

Note that the task returned by the \hs{rebuilder} expects a total callback
function and cannot be directly executed with the partial callback \hs{fetch}.
We fix the mismatch with the function \hs{try} that relies on the standard
monad transformer \hs{ExceptT} from the \cmd{transformers} library.

\begin{figure}
\begin{minted}[fontsize=\small]{haskell}
-- Excel build system
excel :: Ord k => Build Monad (ExcelInfo k) k v
excel = restarting approximateRebuilder
\end{minted}
\vspace{0mm}
\begin{minted}[fontsize=\small]{haskell}
-- Build information: dirty keys, approximate dependencies, and calculation chain
type Chain k = [k]
type ExcelInfo k = ((Set k, Map k [k]), Chain k)
\end{minted}
\vspace{0mm}
\begin{minted}[fontsize=\small]{haskell}
-- A task rebuilder based on the set of dirty keys and approximate dependencies
approximateRebuilder :: Ord k => Rebuilder Monad (Set k, Map k [k]) k v
approximateRebuilder key value task = Task $ \fetch -> do
    (dirtyKeys, deps) <- get
    let dirty = key `Set.member` dirtyKeys ||
                case Map.lookup key deps of Nothing -> True
                                            Just ks -> any (`Set.member` dirtyKeys) ks
    if not dirty then return value else do
        put (Set.insert key dirtyKeys, deps)
        run task fetch
\end{minted}
\vspace{0mm}
\begin{minted}[fontsize=\small]{haskell}
-- A restarting task scheduler
restarting :: Ord k => Rebuilder Monad i k v -> Build Monad (i, Chain k) k v
restarting rebuilder tasks target = execState $ do
    chain    <- gets (snd . getInfo)
    newChain <- go Set.empty $ chain ++ [target | target `notElem` chain]
    modify . mapInfo $ \(i, _) -> (i, newChain)
  where
    go :: Set k -> Chain k -> State (Store (i, Chain k) k v) (Chain k)
    go _    [@@]       = return [@@]
    go done (key:ks) = case tasks key of
        Nothing -> (key :) <$> go (Set.insert key done) ks
        Just task -> do
            store <- get
            let newTask :: Task (MonadState i) k (Either k v)
                newTask = try $ rebuilder key (getValue key store) task
                fetch :: k -> State i (Either k v)
                fetch k | k `Set.member` done = return $ Right (getValue k store)
                        | otherwise           = return $ Left k
            case runState (run newTask fetch) (fst $ getInfo store) of
                (Left dep, _) -> go done $ [ dep | dep `notElem` ks ] ++ ks ++ [key]
                (Right newValue, newInfo) -> do
                    modify $ putInfo (newInfo, [@@]) . putValue key newValue
                    (key :) <$> go (Set.insert key done) ks
\end{minted}
\vspace{0mm}
\begin{minted}[fontsize=\small]{haskell}
-- Convert a total task into a task accepting a partial fetch callback
try :: Task (MonadState i) k v -> Task (MonadState i) k (Either e v)
try task = Task $ \fetch -> runExceptT $ run task (ExceptT . fetch)
\end{minted}
\vspace{-2mm}
\caption{An implementation of \Excel using our framework.}\label{fig-excel-implementation}
\vspace{-4mm}
\end{figure}

\vspace{-2mm}
\subsection{\Shake}\label{sec-implementation-shake}
\vspace{-1mm}

The \Shake approach for dependency tracking involves recording traces and
verifying them, for which we use the \hs{Trace} type defined
in~\ref{sec-verifying-traces}. Complete code is given
in~\S\ref{fig-shake-implementation}, split into three functions:

\begin{description}
\item[\hs{traceMatch}] takes a list of all recorded \hs{Trace} values, the
    \hs{key} you are currently building, and a function \hs{check} which checks
    a specified dependency. It returns the \hs{result} field of all traces that
    match. Since \hs{check} is in an arbitrary monad, the function has to use
    \hs{allM}/\hs{&&^} instead of the more usual \hs{all}/\hs{&&}
    functions\footnote{These functions are all available in the \cmd{extra}
    library on Hackage.}.
\item[\hs{recursive}] defines the dependency ordering pattern. It requires a
    \hs{process} function that builds a key given a way to recursively build a
    dependency, and a way to run task to produce result. The main purpose of
    \hs{recursive} is to ensure that in a single run no key is built twice~--~for
    which it extends the \hs{State} monad with a list of \hs{done} keys.
\item[\hs{shake}] ties everything together. First it tests if the traces allow
the current state of the target key. If not, it builds the key and updates the
store. The only subtlety is that Shake calls \hs{fetch} on the keys while
checking them~--~building the last-recorded dependencies before checking them.
One minor annoyance is that the \hs{State} has been extended and thus needs to
be projected using \hs{fst} before it is used.
\end{description}

\begin{figure}
\begin{minted}[fontsize=\small]{haskell}
-- Shake build system
shake :: (Ord k, Hashable v) => Build Monad (VT k v) k v
shake = suspending vtRebuilder
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- A suspending task scheduler
suspending :: Ord k => Rebuilder Monad i k v -> Build Monad i k v
suspending rebuilder tasks key store = fst $ execState (build key) (store, Set.empty)
  where
    build :: k -> State (Store i k v, Set k) v
    build key = case tasks key of
        Nothing -> gets (getValue key . fst)
        Just task -> do
            done <- gets snd
            when (key `Set.notMember` done) $ do
                value <- gets (getValue key . fst)
                let newTask :: Task (MonadState i) k v
                    newTask = rebuilder key value task
                    fetch :: k -> StateT i (State (Store i k v, Set k)) v
                    fetch k = do v <- lift (build k)
                                 put =<< lift (gets (getInfo . fst))
                                 return v
                info <- gets (getInfo . fst)
                (newValue, newInfo) <- runStateT (run newTask fetch) info
                modify $ \(s, _) ->
                    (putInfo newInfo $ putValue key newValue s, Set.insert key done)
            gets (getValue key . fst)
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- Rebuilder based on verifying traces
vtRebuilder :: (Eq k, Hashable v) => Rebuilder Monad (VT k v) k v
vtRebuilder key value task = Task $ \fetch -> do
    vt <- get
    dirty <- not <$> verifyVT key value (fmap hash . fetch) vt
    if not dirty
    then return value
    else do
        (newValue, deps) <- trackM task fetch
        put =<< recordVT key newValue deps (fmap hash . fetch) =<< get
        return newValue
\end{minted}
\vspace{-3mm}
\caption{An implementation of \Shake using our framework.}\label{fig-shake-implementation}
\vspace{1mm}
\end{figure}

\vspace{-2mm}
\subsection{\Bazel}\label{sec-implementation-bazel}
\vspace{-1mm}

\begin{figure}
\begin{minted}[fontsize=\small]{haskell}
-- Bazel build system, implementation of 'restarting2' is omitted (22 lines)
bazel :: (Ord k, Hashable v) => Build Monad (CT k v) k v
bazel = restarting2 ctRebuilder
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- Cloud Shake build system, implementation of 'suspending' is given in Fig. 8
cloudShake :: (Ord k, Hashable v) => Build Monad (CT k v) k v
cloudShake = suspending ctRebuilder
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- Rebuilder based on constructive traces
ctRebuilder :: (Eq k, Hashable v) => Rebuilder Monad (CT k v) k v
ctRebuilder key value task = Task $ \fetch -> do
    ct <- get
    maybeCachedValue <- constructCT key value (fmap hash . fetch) ct
    case maybeCachedValue of
        Just cachedValue -> return cachedValue
        Nothing -> do
            (newValue, deps) <- track task fetch
            put =<< recordCT key newValue deps (fmap hash . fetch) =<< get
            return newValue
\end{minted}
\vspace{-2mm}
\caption{Implementations of \Bazel and Cloud \Shake using our framework;
\hs{restarting2} differs from the restarting scheduler used by Excel
(Fig.~\ref{fig-excel-implementation}) in that it does not rely on the
calculation chain.}
% \hs{topological} is defined in Fig.~\ref{fig-make-implementation}.
\label{fig-bazel-cloud-shake-implementation}
\vspace{-2mm}
\end{figure}

Now we have seen all three dependency schemes, we can directly reuse
\hs{topological} to define \Bazel. Furthermore, as \Bazel is a tracing build
system, we can reuse \hs{Trace} and \hs{traceMatch}, along with the \hs{Traces}
type from \S\ref{sec-constructive-traces}. With these pieces in place, the
implementation of \Bazel is given in
Fig.~\ref{fig-bazel-cloud-shake-implementation}. We first figure out the
possible results given the current state. If there are no recorded traces for
the current dependencies we run it and record the results, otherwise grab a
suitable result from the \hs{contents} cache.

The program presented above captures certain aspects of \Bazel, but the real
implementation makes one important additional assumption on \hs{Task} -- namely
that it is \textit{deterministic}. With that assumption \Bazel is able to create
the result hash in a trace by hashing together the result hashes of the
dependencies and the key -- as the mapping between dependencies and results is
deterministic. As a consequence \Bazel can compute the results of traces locally,
without looking at \hs{Traces} (potentially saving a roundtrip to the server).
To model this change in the code would require storing an additional transient
piece of information \hs{done} of type \hs{Map}~\hs{k}~\hs{(Hash}~\hs{v)},
storing the computed hashes so far this run. With that available,
\hs{getHash}~\hs{key}~\hs{s} would become:
\begin{minted}[xleftmargin=10pt]{haskell}
hash (key, [ done Map.! d | d <- ds ])
\end{minted}
And that new hash would have to be stored in \hs{done}.

\subsection{Cloud \Shake}\label{sec-implementation-cloud-shake}

Using the abstractions and approaches built thus far, we have shown how to
combine dependency scheme and change approach to reproduce existing build
systems. In the attached materials we have implemented 9~build systems
corresponding to all three dependency schemes, matched with all three change
approaches. To us, the most interesting build system as yet unavailable would
matching recursive ordering with constructive traces~--~providing a cloud-capable
build system with minimality, cutoff and monadic dependencies. Using our
framework it is possible to define and test such a system as per
Fig.~\ref{fig-bazel-cloud-shake-implementation}.

The differences from \hs{bazel} are minor~--~the dependency scheme has changed
from \hs{topological} to \hs{recursive}, and thus the dependency keys \hs{dk}
are captured from the action rather than in advance, the transient state has
gained a list of keys, and the checking calls \hs{fetch} to get the result
instead of accessing the store directly.

\begin{figure}
\begin{minted}[fontsize=\small]{haskell}
-- Buck build system, implementation of 'topological' is given in Fig. 6
buck :: (Hashable k, Hashable v) => Build Applicative (DCT k v) k v
buck = topological (unliftRebuilder dctRebuilder)
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- Convert a monadic rebuilder to the corresponding applicative one
unliftRebuilder :: Rebuilder Monad i k v -> Rebuilder Applicative i k v
unliftRebuilder rebuilder key value task = rebuilder key value $ Task $ run task
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- Nix build system, implementation of 'suspending' is given in Fig. 8
nix :: (Hashable k, Hashable v) => Build Monad (DCT k v) k v
nix = suspending dctRebuilder
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- Rebuilder based on deterministic constructive traces
dctRebuilder :: (Hashable k, Hashable v) => Rebuilder Monad (DCT k v) k v
dctRebuilder key _value task = Task $ \fetch -> do
    dct <- get
    maybeCachedValue <- constructDCT key (fmap hash . fetch) dct
    case maybeCachedValue of
        Just cachedValue -> return cachedValue
        Nothing -> do
            (newValue, deps) <- trackM task fetch
            put =<< recordDCT key newValue deps (fmap hash . fetch) =<< get
            return newValue
\end{minted}
\vspace{-2mm}
\caption{Implementations of \Buck and \Nix using our framework.}
\label{fig-buck-nix-implementation}
\vspace{-2mm}
\end{figure}

\vspace{-1mm}
\subsection{Smarter \hs{[Trace]} data structures}\label{sec-smart-traces}
\vspace{-1mm}

In the examples above, we have used \hs{[Trace}~\hs{k}~\hs{v]} to capture a list
of traces~--~however, using a list necessarily means that finding the right trace
takes $O(n)$. For each of the \hs{Trace} based systems it is possible to devise
a smarter representation, which we sketch below. Note that these implementations
do not avoid calls to \hs{compute}, merely overheads in the build system itself.

\begin{enumerate}
\item Any system using verifying traces, e.g. \Shake, is unlikely to see significant benefit from storing more than one \hs{Trace} per key\footnote{There is a small chance of a benefit if the dependencies change but the result does not, and then the dependencies change back to what they were before.}. Therefore, such systems can store \hs{Map}~\hs{k}~\hs{(Trace}~\hs{k}~\hs{v)}, where the initial \hs{k} is the \hs{key} field of \hs{Trace}.
\item Any system using \hs{Applicative} dependencies can omit the dependency keys from the \hs{Trace} as they can be recovered from the \hs{key} field.
\item Any \hs{Applicative} build system storing constructive traces, e.g. \Bazel, can index directly from the key and results to the output result~--~i.e. \hs{Map}~\hs{(@@k,}~\hs{[Hash}~\hs{v])}~\hs{(Hash}~\hs{v)}. Importantly, assuming the traces are stored on a central server, the client can compute the key and the hashes of its dependencies, then make a single call to the server to retrieve the result hash. In this formulation we have removed the possibility for a single key/dependency state to map to multiple different hashes, e.g. on a non-deterministic build~--~something \Bazel already prohibits which is discussed more in~\S\ref{sec-non-determinism}.
\item Finally, a \hs{Monad} build system with constructive traces can be stored as \hs{Map}~\hs{k}~\hs{(Choice}~\hs{k}~\hs{v)}, assuming a definition of \hs{Choice} as:
\begin{minted}[xleftmargin=10pt]{haskell}
data Choice k v = Choice k (Map (Hash v) (Choice k v))
                | Result (Hash v)
\end{minted}
Here the \hs{Choice} encodes a tree, asking successive questions about keys, and taking different branches based on the answers, until it reaches a final result. Implementing this structure over client-server communication requires either a chatty interface with lots of round-trips per \hs{Choice} step, or sending over a part of the tree that is not subsequently explored.
\end{enumerate}
