\section{Build systems, concretely}\label{sec-implementations}

In the previous sections we discussed the types of build systems, and how they
can be broken down. But these divisions were not obvious to us, and only by
concretely implementing and refactoring each build system did we determine the
underlying commonalities. In this section we share some of the code that got us
there.

% Our code comprises a framework, utility functions implementing the
% various dependency orderings as per~\S\ref{sec-dependency-orderings}, and
% actual implementations.

% \subsection{Framework}

% todo{SLPJ}{I think this entire section, including the mysterious M, can be deleted.  Or is
% there anything that remains?}

% \begin{figure}
% \begin{minted}{haskell}
% type M i k v r = State (i, k -> v, ...) r
% runM :: Default i => M i k v a -> Maybe i -> (k -> v) -> (i, k -> v)

% getStore :: k -> M i k v v
% putStore :: k -> v -> M i k v ()
% getInfo :: M i k v i
% modifyInfo :: (i -> i) -> M i k v ()
% \end{minted}
% Note: we have omitted the context on \hs{k}, things like \hs{Eq} (to implement the store).
% \caption{API with which to implement build systems}
% \label{fig-M-api}
% \end{figure}

% We use \hs{runM} to switch between the pure world of \hs{Build} and a state monad \hs{M} which lets us more precisely express the ideas behind the build system without threading the state manually - the types of important operations are given in Figure~\ref{fig-M-api}. We provide functions like \hs{getStore} to load from the store and \hs{putStore} to write to the store. We'll introduce the other functions in in the monad \hs{M} as we need them while exploring the build systems.

\subsection{\Make}\label{sec-implementation-make}

We provide the complete implementation of \Make in our framework in
Fig.~\ref{fig-make-implementation}. \Make processes keys in a linear order based
on the topological sort (see~\S\ref{sec-concurrency} for parallel \Make). For
each key, it builds it if it is older than any of its dependencies. We capture
the persistent build information that \Make stores by a pair
\hs{(@@modTime,}~\hs{now)} comprising the \emph{file modification time} function
\hs{modTime}~\hs{::}~\hs{k}~\hs{->}~\hs{Time} and the \emph{current time} \hs{now}.
Setting aside the explicit manipulation of file modification times, which in
reality is taken care of by the file system, the function \hs{make} captures
the essence of \Make in a clear and precise manner.

\begin{figure}
\begin{minted}[fontsize=\small]{haskell}
-- Persistent build information
type Time       = Integer
type MakeInfo k = (k -> Time, Time)
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- Make build system
make :: Eq k => Build Applicative (MakeInfo k) k v
make = topological process
  where
    process key deps act = do
        (modTime, now) <- getInfo <$> get
        let dirty = or [ modTime dep > modTime key | dep <- deps ]
        when dirty $ do
            v <- act
            let newModTime k = if k == key then now else modTime k
            modify $ \s -> putInfo (putValue s key v) (newModTime, now + 1)
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- Standard graph algorithms (implementation omitted)
transitiveClosure :: Eq a => (a -> [a]) ->  a  -> [a]
topologicalSort   :: Eq a => (a -> [a]) -> [a] -> [a]
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- Topological dependency strategy
topological :: Eq k => (k -> [k] -> State (Store i k v) v -> State (Store i k v) (@@))
            -> Build Applicative i k v
topological process task key = execState $ forM_ chain $ \k -> do
    let fetch k = do store <- get; return (getValue store k)
    case task fetch k of
        Nothing  -> return ()
        Just act -> process k (deps k) act
  where
    deps  = dependencies task
    chain = topologicalSort deps (transitiveClosure deps key)
\end{minted}
\vspace{-2mm}
\caption{An implementation of \Make using our framework.}\label{fig-make-implementation}
\vspace{-2mm}
\end{figure}

The helper function \hs{topological} calls \hs{process} on every \hs{key} in
the topological order, providing the list of its dependencies \hs{deps} and the
action \hs{act} to compute the resulting value if it needs to be rebuilt. To
determine if the \hs{key} is \hs{dirty}, \hs{process} compares its modification
time with those of its dependencies. If the \hs{key} needs to be rebuilt, the
action \hs{act} is executed and the obtained result is stored, along with an
updated file modification timestamp.

The implementation of \hs{topological} encodes the dependency strategy that
\Make has chosen to use. The \hs{where} clause corresponds to the pre-processing
stage, which uses the function \hs{dependencies}, defined in~\S\ref{sec-deps},
to extract static dependencies from the provided applicative \hs{task}. We
compute the linear processing \hs{chain} by taking the \hs{transitiveClosure}
of \hs{key}'s dependencies, and performing the \hs{topologicalSort} of the
result. We omit implementation of textbook graph algorithms
\hs{transitiveClosure} and \hs{topologicalSort}, e.g.
see~\cite{cormen2001introduction}.

The \hs{chain} is processed in the \hs{State} monad, with each non-input key
\hs{k} in the chain passed to the provided \hs{process} function, along with
\hs{k}'s dependencies and the action \hs{act}, which when executed recomputes
the \hs{k}'s value by fetching its dependencies from the store.

Note that \hs{dependencies} is only defined for applicative tasks, which is what
restricts \Make to static dependencies, as reflected in the
type~\hs{Build}~\hs{Applicative}. Moreover, any other build system following
the same \hs{topological} approach will also inherit the same restriction.

\todo{AM}{Note that anything updating input files must also update Make's info.}
\todo{AM}{Say that in reality that build rules mutate the state themselves.}

\subsection{\Excel}\label{sec-implementation-excel}

As a programming exercise, \Excel is the most challenging, due to the
complicated reordering dependency strategy that requires retrying out-of-order
operations, see Fig.~\ref{fig-excel-implementation}.

\Excel's persistently stored information is a triple: (i) the dirty bit
function \hs{k}~\hs{->}~\hs{Bool}, (ii) an approximation of key dependencies
\hs{k}~\hs{->}~\hs{DependencyApproximation}~\hs{k} that \Excel uses to handle
dynamic dependencies, and (iii) the calculation chain \hs{[@@k]} recorded in the
previous build (\S\ref{sec-background-excel}).

\begin{figure}
\begin{minted}[fontsize=\small]{haskell}
-- Approximation of task dependencies
data DependencyApproximation k = SubsetOf [k] | Unknown
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- Persistent build information
type CalcChain k = [k]
type ExcelInfo k = ((k -> Bool, k -> DependencyApproximation k), CalcChain k)
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- Result of speculative task execution
data Result k v = MissingDependency k | Result v [k]
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- Reordering dependency strategy (implementation omitted)
reordering :: Ord k
    => (k -> State (Store i k v) (Result k v) -> State (Store i k v) (Maybe (Result k v)))
    -> Build Monad (i, CalcChain k) k v
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- Excel build system
excel :: Ord k => Build Monad (ExcelInfo k) k v
excel = reordering process
  where
    process key act = do
        (dirty, deps) <- getInfo <$> get
        let rebuild = dirty key || case deps key of SubsetOf ks -> any dirty ks
                                                    Unknown     -> True
        if not rebuild
            then return Nothing
            else do
                result <- act
                case result of
                    MissingDependency _ -> return ()
                    Result v _dynamicDependencies -> do
                        let newDirty k = if k == key then True else dirty k
                        modify $ \s -> putInfo (putValue s key v) (newDirty, deps)
                return (Just result)
\end{minted}
\vspace{-2mm}
\caption{An implementation of \Excel using our framework.}\label{fig-excel-implementation}
\vspace{-2mm}
\end{figure}

The helper function \hs{reordering}, whose implementation we omit since it is
technical and not particularly enlightening, calls the function \hs{process} to
\emph{try to build} a \hs{key} by executing the action \hs{act}, in the order
determined by the calculation chain. To decide whether to \hs{rebuild} the
\hs{key}, \hs{process} checks if the \hs{key} itself is marked dirty or the
approximation of its dependencies contains a dirty key. Notice that if the
dependencies of the \hs{key} are \hs{Unknown}, e.g. when it uses the
\cmd{INDIRECT} function, the \hs{key} is always rebuilt. If a \hs{rebuild} is
not needed, \hs{process} returns \hs{Nothing} to indicate this. Otherwise, it
executes \hs{act} leading to two possible \hs{result}s:

\begin{itemize}
    \item \hs{MissingDependency}~\hs{k} indicates that the execution of \hs{act} has
    failed, because one of its dependencies \hs{k} was out-of-date, i.e. the
    calculation chain from the previous build was incorrect and therefore needs
    to be reordered, deferring the \hs{key} to be rebuilt later.
    \item \hs{Result}~\hs{v}~\hs{dynamicDependencies} indicates that the
    execution has succeeded producing the value~\hs{v} and the list of the
    \hs{key}'s dynamic dependencies. We store the value, and mark it dirty to
    trigger the rebuilding of keys that depend on it.
\end{itemize}

In both of the above cases, we notify the parent \hs{reordering} function about
the outcome by returning \hs{Just}~\hs{result}. The astute reader may notice
that \hs{process} ignores \hs{dynamicDependencies} available in the \hs{result}.
While not required for \Excel, we have implemented build systems using
\hs{reordering} which use verifying and constructive traces, effectively turning
\Excel into a cloud build system and ensuring \hs{reordering} is not overly
fitted to \Excel alone (additional implementations will be submitted to the
Artefact Evaluation).

\subsection{\Shake}\label{sec-implementation-shake}

The \Shake approach for dependency tracking involves recording traces and verifying them, for which we use the \hs{Trace} type defined in \ref{sec-verifying-traces}. Complete code is given in \S\ref{fig-shake-implementation}.

\begin{figure}
\begin{minted}[fontsize=\small]{haskell}
-- Determine whether a trace is relevant to the current state
traceMatch :: (Monad m, Eq k) => (k -> Hash v -> m Bool) -> k -> [Trace k v] -> m [Hash v]
traceMatch check key ts = mapMaybeM f ts
    where f (Trace k dkv v) = do
                b <- return (key == k) &&^ allM (uncurry check) dkv
                return $ if b then Just v else Nothing
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- Recursive dependency strategy
recursive
    :: Eq k => (k -> (k -> State (Store i k v, [k]) v) -> State (Store i k v, [k]) (v, [k]) -> State (Store i k v, [k]) ())
    -> Build Monad i k v
recursive step task key store = fst $ execState (ensure key) (store, [])
    where
        ensure key = do
            let fetch k = do ensure k; gets (getValue k . fst)
            s <- get
            when (key `notElem` snd s) $ do
                modify $ \(s, done) -> (s, key:done)
                case trackM task fetch key of
                    Nothing -> return ()
                    Just act -> step key fetch act
\end{minted}
\vspace{1mm}
\begin{minted}[fontsize=\small]{haskell}
-- Shake build system
shake :: (Eq k, Hashable v) => Build Monad [Trace k v] k v
shake = recursive $ \key fetch act -> do
    traces <- gets (getInfo . fst)
    poss <- traceMatch (\k v -> (==) v . hash <$> fetch k) key traces
    current <- gets (getHash key . fst)
    when (current `notElem` poss) $ do
        (v, ds) <- act
        modify $ \(s, done) ->
            let t = Trace key [(d, getHash d s) | d <- ds] (getHash key s)
            in (putInfo (t : getInfo s) (putValue key v s), done)

\end{minted}
\vspace{-2mm}
\caption{An implementation of \Shake using our framework.}\label{fig-shake-implementation}
\vspace{-2mm}
\end{figure}

This implementation uses the \hs{recursive} function which requires a function which gets the key to build (\hs{k}), a way to fetch the result of a dependency (\hs{fetch}), and a way to build \hs{k} (\hs{act}). The code first looks up the traces that match the current situation, creating a list of possible results as \hs{poss}, using the helper \hs{traceMatch}. We check if the current value for the key is one of the possible results, and it not, build the key and store it in the trace. We can implement \hs{traceMatch}, which is used in all build systems working with \hs{Trace}, as:

The function \hs{traceMatch} requires a way to check a dependency, and the key, and the traces. We return the \hs{result} field from all traces where the key and dependencies match. We define the recursive combinator as:

The required \hs{step} function gets given the \hs{k} to build, the dependencies as \hs{Maybe [k]} (where they are \hs{Nothing} if the rule is truly monadic), a function to demand the result of a dependent key, and a function to compute the current value and return the actual dependencies. To ensure each file is only visited once in a single execution a piece of temporary state is used with \hs{getTemp} and \hs{modifyTemp} to record which files were visited - this state is not persisted to the \hs{i} info parameter and is reset on each fresh execution of \hs{M}.

\subsection{\Bazel}\label{sec-implementation-bazel}

\todo{NM}{Remove the intermediate \hs{M} layer, as done in \Make.}

Now we have seen the three dependency schemes, we can directly reuse \hs{topological} to define \Bazel. Furthermore, as \Bazel is a tracing build system, we can reuse \hs{Trace} and \hs{traceMatch}, as part of the \hs{Traces} type. We define \Bazel as:

\begin{minted}{haskell}
bazel :: Hashable v => Build Applicative (Traces k v) k v
bazel = topological $ \k dk act -> do
    poss <- traceMatch (\k v -> (== v) <$> getStoreHash k) k . traces =<< getInfo
    if null poss then do
        v <- act
        dh <- mapM getStoreHash dk
        modifyInfo $ \i -> i
            {traces = Trace k (zip dk dh) (getHash v) : traces i
            ,contents = Map.insert (getHash v) v $ contents i}
        putStore k v
    else do
        h <- getStoreHash k
        when (h `notElem` poss) $
            putStore k . (Map.! head poss) . contents =<< getInfo
\end{minted}

We execute keys in a topological order. For each key we first get a list of the traces that match. If there are none we rebuild and record the trace, much like \Shake, but also recording the value of the result. If there are some matching traces, and the current value of \hs{k} is not compatible, we grab the first possibility and grab its value from \hs{contents}.

\subsection{Cloud \Shake}\label{sec-implementation-cloud-shake}

\todo{NM}{Remove the intermediate \hs{M} layer, as done in \Make.}

Using the abstractions and approaches built thus far, we have shown how to combine dependency scheme and change approach to reproduce existing build systems. In the attached materials we have implemented 9 build systems corresponding to all three dependency schemes, matched with all three change approaches. To us, the most interesting build system as yet unavailable would matching recursive ordering with constructive traces - providing a cloud-capable build system with minimality, cut-off and monadic dependencies. Using our framework it is possible to define and test such a system:

\begin{minted}{haskell}
cloudShake :: Hashable v => Build Monad (Traces k v) k v
cloudShake = recursive $ \k _ fetch act -> do
    poss <- traceMatch (\k v -> (== v) . getHash <$> fetch k) k . traces =<< getInfo
    if null poss then do
        (dk, v) <- act
        dh <- mapM getStoreHash dk
        modifyInfo $ \i -> i
            {traces = Trace k (zip dk dh) (getHash v) : traces i
            ,contents = Map.insert (getHash v) v $ contents i}
        putStore k v
    else do
        now <- getStoreHash k
        when (now `notElem` poss) $
            putStore k . (Map.! head poss) . contents =<< getInfo
\end{minted}

The differences from \hs{bazel} are minor - the dependency scheme has changed from \hs{topological} to \hs{recursive}, and thus the dependency keys \hs{dk} are captured from the action rather than in advance, and the checking calls \hs{fetch} to get the result instead of accessing the store directly. We believe this accurately captures and can be used to reason about how to make \Shake work with a cloud-based cache -- a challenge we intend to attempt in the future.

\subsection{Smarter \hs{[Trace]} Structures}\label{sec-smart-traces}
\todo{NM}{Remove the intermediate \hs{M} layer, as done in \Make.}

In the examples above, we have used \hs{[Trace]} to capture a list of traces stored in the info field, which accurately models the data and operations. However, using a list necessarily means that finding the right trace takes $O(n)$. For each of the \hs{Trace} based systems it is possible to devise a smarter representation, which we sketch below. Note that these implementations do not avoid calls to \hs{compute}, merely overheads in the build system itself.

\begin{enumerate}
\item Any system using verifying traces, e.g. \Shake, is unlikely to see significant benefit from storing more than one \hs{Trace} per key\footnote{There is a small chance of a benefit if the dependencies change but the result does not, and then the dependencies change back to what they were before.}. Therefore, such systems can store \hs{Map k (Trace k v)}, where the initial \hs{k} is the \hs{key} field of \hs{Trace}.
\item Any system using \hs{Applicative} dependencies can omit the dependency keys from the \hs{Trace} as they can be recovered from the \hs{key} field.
\item Any \hs{Applicative} system storing constructive traces, e.g. \Bazel, can index directly from the key and results to the output result - i.e. \hs{Map (k, [Hash v]) (Hash v)}. Importantly, assuming the traces are stored on a central server, the client can compute the key and the hashes of its dependencies, then make a single call to the server to retrieve the result hash. In this formulation we have removed the possibility for a single key/dependency state to map to multiple different hashes, e.g. on a non-deterministic build - something \Bazel already prohibits which is discussed more in \S\ref{sec-non-determinism}.
\item Finally, a \hs{Monad} system with constructive traces can be efficiently encoded as \hs{Map k (Choice k v)}, assuming a definition of \hs{Choice} as:
\begin{minted}{haskell}
data Choice k v = Choice k (Map (Hash v) Choice)
                | Result (Hash v)
\end{minted}
Here the \hs{Choice} effectively encodes a tree, asking successive questions about keys, and taking different branches based on the resulting value, until it reaches a final result. Implementing this structure over client-server communication requires either a chatty interface with lots of round-trips per \hs{Choice} step, or sending over a part of the tree that is not subsequently explored.
\end{enumerate}

As an aside we note that the optimal cloud structure for applicative and monadic constructive systems has a resemblance to the free dependency structures described in \S\ref{sec-free-build}.


\subsection{Other build systems}

We have implemented the complete product, reusing the \hs{topological} functions etc.
