\clearpage
\section{Build systems, concretely}\label{sec-examples}

In the previous sections we've discussed the types of build system in text, but the way we came to our conclusions was by developing a framework to fit the builds in. In this section we explain the framework, some of the abstractions we introduced (which model the properties from \S\ref{todo}), and how we can make a meaningful implementation of the build systems discussed in \S\ref{sec-background}.

\subsection{Framework}

As we saw in the introduction, a build system can be defined as:

\begin{minted}{haskell}
type Build c i k v = Compute c k v -> k -> Maybe i -> Map.Map k v -> (i, Map.Map k v)
\end{minted}

Using the framework we have built we can express the simplest and stupidest build system as:

\begin{minted}{haskell}
dumb :: Build Monad () k v
dumb compute = runM . f
    where f k = maybe (getStore k) (putStore k =<<) $ compute f k
\end{minted}

\begin{figure}
\begin{minted}{haskell}
data M i k v r
runM :: Default i => M i k v a -> Maybe i -> Map.Map k v -> (i, Map.Map k v)
getStore :: k -> M i k v v
putStore :: k -> v -> M i k v v
\end{minted}
Note: we have omitted the context on \textt{k}, things like \texttt{Ord} (so the implementation can use a finite map) or \texttt{Show} (so the implementation can produce nice error messages).
\caption{API with which to implement build systems}
\label{fig-M-api}
\end{figure}
  
The types of important definitions are given in Figure \ref{fig-M-api}





but 


This section present several concrete examples of build systems, providing
simple implementations that use the previously introduced abstractions.

\subsection{Applicative build systems}

Applicative build system can only accept an applicative compute, because they
rely on building the full dependency graph upfront, which is impossible with
dynamic dependencies.

\vspace{4mm}
\subsubsection{An incorrect applicative build system}~\\

\todo{AM}{Describe the \hs{dumbBuild} that builds outputs in the given order.}

\vspace{4mm}
\subsubsection{\Make: a correct but non-minimal applicative build system}~\\
 
We start by applicative build systems, such as the classic vanilla
\Make\footnote{There are numerous implementations of \Make and none comes with a
formal specification. In this paper we therefore use a simple but reasonable
approximation to a real \Make that you might find on your machine.} and a more
recent \Ninja.

Make is correct but non-minimal. It is unusual from other build systems in that
it relies on \emph{timed values}, i.e. on a map \hs{age :: v -> Time}, as a
heuristic to decide whether a value is up-to-date.

\todo{NM}{Add a description of \Make.}

\vspace{4mm}
\subsubsection{\Ninja: a correct and minimal applicative build system}~\\

\Ninja is a modern alternative to \Make ...

\todo{NM}{Add a description of \Ninja.}

\todo{AM}{What about Nix? John Ericson suggested in a blog comment that it may
be somewhat monadic, see:
\url{https://blogs.ncl.ac.uk/andreymokhov/cloud-and-dynamic-builds/\#comment-1849}.}

\subsection{Monadic build systems}

...
\subsubsection{An incorrect monadic build system}~\\

See \hs{dumbBuild}.

\subsubsection{Correct but not minimal monadic build system}~\\

As of writing, XXX is a correct but non-minimal monadic build system. Here is
an example where it does unnecessary computation:

\begin{minted}[frame=single]{text}
A1 = 10
A2 = MIN(A1, 4)
A3 = SQRT(A2)
\end{minted}

After performing the build, XXX computes \textsf{A2 = 4} and \textsf{A3 = 2}
from the input cell \textsf{A1}. Now if the user changes the \textsf{A1} to 5,
XXX will recompute both \textsf{A2 = 4}, which is necessary, but also
\textsf{A3 = 2}, which is unnecessary since its only dependency (\textsf{A1})
has not changed since the previous build.

One possible implementation of a spreadsheet build
system\footnote{For example, see \url{http://www.decisionmodels.com/calcsecretsc.htm}.}
is to maintain a
sequence of cells in which they should be evaluated. The build system takes this
sequence as input, marks all cells as \emph{unevaluated}, and then attempts to
evaluate all cells in the order specified by the sequence. If the cell to be
evaluated depends on an unevaluated cell, this means the provided sequence is
not a correct topological order and is updated by moving the current cell to the
back of the sequence. The build then proceeds with the next cell. Otherwise, if
all dependencies of the current cell have been marked as \emph{evaluated}, the
build system computes the correct value for the cell by evaluating the formula,
writes it into the spreadsheet and proceeds to the next cell in the sequence. If
there are no cyclic dependencies, this process eventually terminates with
correct results. The resulting sequence, which is guaranteed to respect the
topological order of dependencies is stored to be reused during the next build.

...

Interesting note: XXX is unusual in that it tracks changes in the compute,
i.e. if a user edits a formula, XXX will correctly rebuild results. Most build
systems, including \Shake, do not meet this requirement and a clean rebuild may
be necessary if the user edits build rules.

...

\subsubsection{Correct and minimal monadic build system}~\\

\Shake is a correct and minimal monadic build system.
\todo{NM}{Describe \Shake using our abstractions.}

\subsection{Cloud build systems}

Codebase of large software projects comprises millions of lines of code spread
across thousands of files, each built independently by thousands of developers
on thousands of machines. A distributed cloud build system speeds up builds
dramatically (and saves energy) by transparently sharing build products among
developers.

\todo{AM}{Also mention YYY (developed by ZZZ), Buck (Facebook) and Pants
(Twitter et al). Buck is essentially the same. Are they essentially the same?}

\Bazel is a cloud build system developed by Google, which supports caching of
build results. To achieve that, it maintains two partial maps:

\begin{minted}{haskell}
type Cache =  Hash  -> Maybe v
type Known = [Hash] -> Maybe Hash
\end{minted}

\hs{Cache} is a conventional \emph{content-addressable store}, that can be used
to fetch a previously computed value given its hash.

\hs{Known} records a known outcome of a computation that took a list of values
as input (represented by their hashes) and produced a resulting value (also
represented by its hash). Now, a build system has the following two options to
recompute a value:

\begin{itemize}
    \item Call the compute function on the store containing all up-to-date
    dependencies and put the computed value to the store.
    \item Collect hashes of all up-to-date dependencies \hs{hs} and query the
    \hs{Known} map. If this computation has been performed before, the map will
    contain the hash \hs{h} of one valid result (recall that the compute function
    may be non-deterministic). It is now possible to lookup \hs{h} in the
    \hs{Cache} and if it contains a value \hs{v} it can be downloaded to the
    local store instead of running the compute.
\end{itemize}

...

\todo{AM}{Also describe the XYZ algorithm.}
