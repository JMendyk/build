\section{Build tasks, abstractly}\label{sec-compute}

This section presents purely functional abstractions that allow us to express
all the intricacies of build systems discussed in the previous
section~\S\ref{sec-background} and design complex build systems from simple
primitives. Specifically, we present the \emph{compute} and \emph{build}
abstractions:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
type Compute c k v = @\std{forall}@ f. c f => (k -> f v) -> k -> Maybe (f v)
type Build c i k v = Compute c k v -> k -> Maybe i -> (k -> v) -> (i, k -> v)
\end{minted}
\vspace{1mm}

\noindent
\hs{Compute} represents an abstract set of \emph{build tasks}, for example, build
rules in software build systems or formulas in spreadsheets. It is completely
isolated from the world of compilers, file systems, calculation chains, caches,
and all other complexities of real build systems. We explain the compute type
in~\S\ref{sec-general-compute}, discussing several noteworthy special cases:
functorial, applicative and monadic types of compute.

\hs{Build} corresponds to the algorithm used for bringing a key-value store
\store to a consistent state by recomputing out-of-date values in an
appropriate order. We explain the build type and use it to develop a formal
definition of build systems in~\S\ref{sec-general-build}.
Sections~\S\ref{sec-build} and~\S\ref{sec-implementations} scrutinise the build
abstraction further and provide concrete implementations for several build
systems.

\subsection{Common vocabulary for build systems}
\label{sec-vocabulary}

We start by introducing a common vocabulary for build systems that allows
us to abstract away from specific application domains, such as software
development or spreadsheets.
% We will use this vocabulary throughout the rest of the paper.

\emph{Keys} are used to distinguish \emph{values}. In software build systems,
keys are typically filenames, e.g.~\cmd{main.c}, whereas values are file
contents (a C program source code in this case). In spreadsheets, keys are cell
names, e.g. \cmd{A1}, and values are numbers, text, etc. that are typically
displayed inside cells. In Haskell code, we will use type variables \hs{k}
and \hs{v} to denote keys and values, respectively.

We use a cryptographic \emph{hash function} \hs{hash :: v -> Hash} for efficient
tracking and sharing of~build results, where \hs{Hash} is an abstract data type
equipped with the equality test.

A \emph{store} associates keys to values. It is convenient to assume that a
store is total function \store, i.e. it contains a value for every possible key.
We therefore also assume that the type of values is capable of encoding values
corresponding to non-existent keys (missing files or empty cells). This, in
particular, suggests that it is possible to \emph{depend on the absence of a
value}, which is a useful feature for build systems. In addition to usual
read and write operations, some stores also support a dedicated \emph{read hash}
operation, which is implemented more efficiently than by reading and hashing the
result. For example, GVFS (Git Virtual File System)~\cite{gvfs} stores file
hashes and downloads file contents only on demand -- an important feature for
cloud build systems.

Some values must be provided by the user as \emph{input}. For example,
\cmd{main.c} can be edited by the user who relies on the build system to
compile it into \cmd{main.o} and subsequently \cmd{main.exe}. End build products,
such as \cmd{main.exe}, are \emph{output} values. All other values (in this case
\cmd{main.o}) are \emph{intermediate}; they are not interesting for the user
but are produced in the process of turning inputs into outputs.

\subsection{Compute}\label{sec-compute-applicative}

We describe build tasks and their dependencies using functions of type
\hs{Compute}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
type Compute c k v = @\std{forall}@ f. c f => (k -> f v) -> k -> Maybe (f v)
\end{minted}
\vspace{1mm}

\noindent
A compute takes two arguments: \hs{fetch :: k -> f v} and \hs{key :: k}, and
returns either \hs{Nothing} to indicate that the \hs{key} is an input and hence
cannot be computed, or \hs{Just}~\hs{value} obtained by \hs{fetch}ing the
dependencies of the \hs{key} and performing the required computation. A compute
must be polymorphic in \hs{f} but may request certain computational
power\footnote{Readers familiar with \emph{lenses} or \emph{profunctor optics}
might recognise a familiar pattern. We discuss this in~\S\ref{sec-related-optics}.}
by specifying the constraint~\hs{c}. Let us look at an example by recalling the
following spreadsheet from~\S\ref{sec-background-excel}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{bash}
A1 = 10
A2 = 20
B1 = A1 + A2
\end{minted}
\vspace{1mm}

\noindent
The only build task in this spreadsheet can be expressed as an \emph{applicative
compute}, operating on keys (cell names) of type \hs{String} and values of
type \hs{Integer}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
add :: Compute Applicative String Integer
add fetch key | key /= "B1" = Nothing
              | otherwise   = Just $ (+) <$> fetch "A1" <*> fetch "A2"
\end{minted}
\vspace{1mm}

\noindent
The cells \cmd{A1} and \cmd{A2} are inputs, which is indicated by returning
\hs{Nothing}. The cell \cmd{B1} is an output, whose value is computed by
fetching the values of \cmd{A1} and \cmd{A2} and applying the pure
function~\hs{(+)} using the methods of the \hs{Applicative} type
class~\cite{mcbride2008applicative}.

The \hs{Compute} type and the example above might seem mysterious. Why insist on
\hs{Compute} to be polymorphic in \hs{f}? Why choose the \hs{Applicative}
constraint?

The answer to both questions is that we can statically analyse an applicative
compute and extract all dependencies of a key using the following function:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
dependencies :: Compute Applicative k v -> k -> [k]
dependencies compute = maybe [@@] getConst . compute (\k -> Const [k])
\end{minted}
\vspace{1mm}

\noindent
We can use this function to extract dependencies of \hs{add}, as shown in the
following GHCi session:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
@\ghci@ dependencies add "A1"
[@@]
\end{minted}
\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
@\ghci@ dependencies add "B1"
["A1", "A2"]
\end{minted}
\vspace{1mm}

\noindent
It is important to note that we extract the dependencies without providing any
values to the compute. This guarantees that no actual computation is performed
during the analysis -- we cannot execute the function \hs{(+)} if we have no
values for it! Static analysis of applicative computations is not new and has
been used to similar effect before, e.g. see~\cite{free-applicatives}.

To understand how \hs{dependencies} works, let us examine its type more closely,
expanding the type synonym \hs{Compute}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
(@\std{forall}@ f. Applicative f => (k -> f v) -> k -> Maybe (f v)) -> k -> [k]
\end{minted}
\vspace{1mm}

\noindent
Since the first argument is polymorphic in \hs{f}, we can choose any \hs{f} that
satisfies the \hs{Applicative} constraint. A good choice in this case is the
applicative functor \hs{Const} defined in the standard module
\cmd{Data.Functor.Const}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
newtype Const m a = Const { getConst :: m }

instance Functor (Const m) where
    fmap _ (Const m) = Const m

instance Monoid m => Applicative (Const m) where
    pure _              = Const mempty
    Const x <*> Const y = Const (x <> y)
\end{minted}
\vspace{1mm}

\noindent
A value of type \hs{Const}~\hs{[}\hs{k]}~\hs{v} contains no values \hs{v} but
allows us to record all invocations of the custom \hs{fetch} function that we
feed to the given compute: \hs{fetch k = Const [k]}. The compute returns a
value of type \hs{Maybe}~\hs{(Const}~\hs{[}\hs{k]}~\hs{v)}, which we unwrap
using \hs{maybe [@@] getConst} since inputs have no dependencies.

We can also execute a compute on a given store to obtain the resulting value.
This uses a very similar transformation based on the \hs{Identity} monad
defined in \cmd{Data.Functor.Identity}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
execute :: Compute Monad k v -> (k -> v) -> k -> Maybe v
execute compute store = fmap runIdentity . compute (Identity . store)
\end{minted}
\vspace{1mm}

\noindent
Note that \hs{execute} can accept both an applicative as well as a \emph{monadic
compute} introduced in~\S\ref{sec-compute-monad}. Below we run \hs{execute} on
the above \hs{add} example. Note that \hs{execute} returns \hs{Nothing} for
inputs.

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
@\ghci@ store key = if key == "A1" then 10 else 20
@\ghci@ execute add store "A1"
Nothing
\end{minted}
\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
@\ghci@ execute add store "B1"
Just 30
\end{minted}
\vspace{1mm}

\subsection{Monadic compute}\label{sec-compute-monad}


\subsection{Compute examples (likely to be removed)}

The \emph{Collatz sequence} $C_i$ is defined as follows:

\[
C_{i} = {\begin{cases}~n&{\text{for }}i=0\\~f(C_{i-1})&{\text{otherwise}},\end{cases}}\hspace{12pt}\text{where}\hspace{12pt}f(k)={\begin{cases}~k/2&{\text{if }}k\text{ is even}\\~3k+1&{\text{otherwise}}\end{cases}}
\vspace{2mm}
\]
\noindent
and $n$ is a positive integer parameter. The famous \emph{Collatz conjecture}
states that the Collatz sequence eventually reaches 1 for all possible values of
$n$. For example, if $n=6$, we reach 1 in eight steps:
$(6, 3, 10, 5, 16, 8, 4, 2, 1, \dots)$, after which the sequence loops forever:
$(4, 2, 1, 4, 2, 1, \dots)$.

We can express the computation of values in the Collatz sequence as a functorial
compute:

\begin{minted}[xleftmargin=10pt]{haskell}
data Collatz = Collatz Int

collatz :: Compute Functor Collatz Int
collatz get (Collatz k) | k <= 0    = Nothing
                        | otherwise = Just $ f <$> get (Collatz (k - 1))
  where
    f n | even n    = n `div` 2
        | otherwise = 3 * n + 1
\end{minted}

...

The \emph{generalised Fibonacci sequence} $F_i$ is defined as follows:

\[
F_{i} = {\begin{cases}~n&{\text{for }}i=0\\~m&{\text{for }}i=1\\~F_{i-1}+F_{i-2}&{\text{otherwise}}\end{cases}}
\vspace{2mm}
\]
\noindent
where $n$ and $m$ are integer parameters. By setting $n=0$ and $m=1$ we obtain
the famous \emph{Fibonacci sequence}: $(0, 1, 1, 2, 3, 5, 8, 13, \dots$), and if
$n=2$ and $m=1$, the result is the \emph{Lucas sequence}:
$(2, 1, 3, 4, 7, 11, 18, 29, \dots)$.

We can express the computation of values in the generalised Fibonacci sequence
as an applicative compute:

\begin{minted}[xleftmargin=10pt]{haskell}
data Fibonacci = Fibonacci Int

fibonacci :: Compute Applicative Fibonacci Int
fibonacci get (Fibonacci k) | k <= 1    = Nothing
                            | otherwise = Just $ (+) <$> get (Fibonacci (k - 1))
                                                     <*> get (Fibonacci (k - 2))
\end{minted}

...

The \emph{Ackermann function} $A(m, n)$ is defined as follows:

\[
A(m, n) = {\begin{cases}~n+1&{\text{for }}m=0\\~A(m-1, 1)&{\text{for }}n=0\\~A(m-1,A(m,n-1))&{\text{otherwise}}\end{cases}}
\vspace{2mm}
\]
\noindent
We can express the computation of the Ackermann function as a monadic compute:

\begin{minted}[xleftmargin=10pt]{haskell}
data Ackermann = Ackermann Int Int

ackermann :: Compute Monad Ackermann Int
ackermann get (Ackermann m n)
    | m < 0 || n < 0 = Nothing
    | m == 0    = Just $ return (n + 1)
    | n == 0    = Just $ get (Ackermann (m - 1) 1)
    | otherwise = Just $ do
        index <- get (Ackermann m (n - 1))
        get (Ackermann (m - 1) index)
\end{minted}

...

\subsection{Build}\label{sec-general-build}

...

\todo{AM}{Provide a formal definition of `correctness', which does not rely on materialising intermediate values.}

\subsection{Free build structures}\label{sec-free-build}

\begin{minted}{haskell}
data Depend k v r = Depend [k] ([v] -> r)

data Depends k v r = Depends [k] ([v] -> Depends k v r)
                   | Done r
\end{minted}
