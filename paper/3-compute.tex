\section{Build tasks, abstractly}\label{sec-compute}

This section presents purely functional abstractions that allow us to express
all the intricacies of build systems discussed in the previous
section~\S\ref{sec-background} and design complex build systems from simple
primitives. Specifically, we present the \emph{compute} and \emph{build}
abstractions:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
type Compute c k v = @\std{forall}@ f. c f => (k -> f v) -> k -> Maybe (f v)
type Build c i k v = Compute c k v -> k -> Maybe i -> (k -> v) -> (i, k -> v)
\end{minted}
\vspace{1mm}

\noindent
\hs{Compute} represents an abstract collection of \emph{build tasks}, for
example, build rules in software build systems or formulas in spreadsheets. It
is completely isolated from the world of compilers, calculation chains, file
systems, caches, and all other complexities of real build systems. We explain
the compute type in~\S\ref{sec-compute-applicative}, discussing several
noteworthy special cases: functorial, applicative and monadic types of compute.

\hs{Build} corresponds to the algorithm used for bringing a key-value store
\store to a consistent state by recomputing out-of-date values in an
appropriate order. We explain the build type and use it to develop a formal
definition of build systems in~\S\ref{sec-general-build}.
Sections~\S\ref{sec-build} and~\S\ref{sec-implementations} scrutinise the build
abstraction further and provide concrete implementations for several build
systems.

\subsection{Common vocabulary for build systems}
\label{sec-vocabulary}

We start by introducing a common vocabulary for build systems that allows
us to abstract away from specific application domains, such as software
development or spreadsheets.
% We will use this vocabulary throughout the rest of the paper.

\emph{Keys} are used to distinguish \emph{values}. In software build systems,
keys are typically filenames, e.g.~\cmd{main.c}, whereas values are file
contents (a C program source code in this case). In spreadsheets, keys are cell
names, e.g. \cmd{A1}, and values are numbers, text, etc. that are typically
displayed inside cells. In Haskell code, we will use type variables \hs{k}
and \hs{v} to denote keys and values, respectively.

We use a cryptographic \emph{hash function} \hs{hash :: v -> Hash} for efficient
tracking and sharing of~build results, where \hs{Hash} is an abstract data type
equipped with the equality test.

A \emph{store} associates keys to values. It is convenient to assume that a
store is total function \store, i.e. it contains a value for every possible key.
We therefore also assume that the type of values is capable of encoding values
corresponding to non-existent keys (missing files or empty cells). This, in
particular, suggests that it is possible to \emph{depend on the absence of a
value}, which is a useful feature for build systems. In addition to usual
read and write operations, some stores also support a dedicated \emph{read hash}
operation, which is implemented more efficiently than by reading and hashing the
result. For example, GVFS (Git Virtual File System)~\cite{gvfs} stores file
hashes and downloads file contents only on demand -- an important feature for
cloud build systems.

Some values must be provided by the user as \emph{input}. For example,
\cmd{main.c} can be edited by the user who relies on the build system to
compile it into \cmd{main.o} and subsequently \cmd{main.exe}. End build products,
such as \cmd{main.exe}, are \emph{output} values. All other values (in this case
\cmd{main.o}) are \emph{intermediate}; they are not interesting for the user
but are produced in the process of turning inputs into outputs.

\subsection{Compute}\label{sec-compute-applicative}

We describe build tasks and their dependencies using functions of type
\hs{Compute}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
type Compute c k v = @\std{forall}@ f. c f => (k -> f v) -> k -> Maybe (f v)
\end{minted}
\vspace{1mm}

\noindent
A compute takes two arguments: \hs{fetch :: k -> f v} and \hs{key :: k}, and
returns either \hs{Nothing} to indicate that the \hs{key} is an input and hence
cannot be computed, or \hs{Just}~\hs{value} obtained by \hs{fetch}ing the
dependencies of the \hs{key} and performing the required computation. A compute
must be polymorphic in \hs{f} but may request certain computational
power\footnote{Readers familiar with \emph{lenses} or \emph{profunctor optics}
might recognise a familiar pattern. We discuss this in~\S\ref{sec-related-optics}.}
by specifying the constraint~\hs{c}. Let us look at an example by recalling the
following spreadsheet from~\S\ref{sec-background-excel}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{bash}
A1 = 10
A2 = 20
B1 = A1 + A2
\end{minted}
\vspace{1mm}

\noindent
The only build task in this spreadsheet can be expressed as an \emph{applicative
compute}, operating on keys (cell names) of type \hs{String} and values of
type \hs{Integer}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
add :: Compute Applicative String Integer
add fetch key | key /= "B1" = Nothing
              | otherwise   = Just $ (+) <$> fetch "A1" <*> fetch "A2"
\end{minted}
\vspace{1mm}

\noindent
The cells \cmd{A1} and \cmd{A2} are inputs, which is indicated by returning
\hs{Nothing}. The cell \cmd{B1} is an output, whose value is computed by
fetching the values of \cmd{A1} and \cmd{A2} and applying the pure
function~\hs{(+)} using the methods of the \hs{Applicative} type
class~\cite{mcbride2008applicative}.

The \hs{Compute} type and the example above might seem mysterious. Why insist on
\hs{Compute} to be polymorphic in \hs{f}? Why choose the \hs{Applicative}
constraint?

The answer to both questions is that we can statically analyse an applicative
compute and extract all dependencies of a key using the following function:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
import Data.Functor.Const
\end{minted}
\vspace{0.5mm}
\begin{minted}[xleftmargin=10pt]{haskell}
dependencies :: Compute Applicative k v -> k -> [k]
dependencies compute = maybe [@@] getConst . compute (\k -> Const [k])
\end{minted}
\vspace{1mm}

\noindent
We can use this function to extract dependencies of \hs{add}, as shown in the
following GHCi session:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
@\ghci@ dependencies add "A1"
[@@]
\end{minted}
\begin{minted}[xleftmargin=10pt]{haskell}
@\ghci@ dependencies add "B1"
["A1", "A2"]
\end{minted}
\vspace{1mm}

\noindent
It is important to note that we extract the dependencies without providing any
values to the compute. This guarantees that no actual computation is performed
during the analysis -- we cannot execute the function \hs{(+)} if we have no
values for it! Static analysis of applicative computations is not new and has
been used to similar effect before, e.g. see~\cite{free-applicatives}.

To understand how \hs{dependencies} works, let us examine its type more closely,
expanding the type synonym \hs{Compute}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
(@\std{forall}@ f. Applicative f => (k -> f v) -> k -> Maybe (f v)) -> k -> [k]
\end{minted}
\vspace{1mm}

\noindent
Since the first argument is polymorphic in \hs{f}, we can choose any \hs{f} that
satisfies the \hs{Applicative} constraint. A good choice in this case is the
applicative functor \hs{Const}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
newtype Const m a = Const { getConst :: m }
\end{minted}
\vspace{0.5mm}
\begin{minted}[xleftmargin=10pt]{haskell}
instance Functor (Const m) where
    fmap _ (Const m) = Const m
\end{minted}
\vspace{0.5mm}
\begin{minted}[xleftmargin=10pt]{haskell}
instance Monoid m => Applicative (Const m) where
    pure _              = Const mempty
    Const x <*> Const y = Const (x <> y)
\end{minted}
\vspace{1mm}

\noindent
A value of type \hs{Const}~\hs{[}\hs{k]}~\hs{v} contains no values \hs{v} but
allows us to record all invocations of the custom \hs{fetch} function that we
feed to the given compute: \hs{fetch k = Const [k]}. The compute returns a
value of type \hs{Maybe}~\hs{(Const}~\hs{[}\hs{k]}~\hs{v)} that can be
unwrapped using \hs{maybe [@@] getConst}, i.e. returning the empty list of
dependencies in case of an input.

We can also \hs{execute} a compute on a given store. This relies on a similar
transformation, now based on the \hs{Identity} monad (see
Appendix~\S\ref{sec-appendix-transformers} for the implementation of
\hs{Identity}):

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
import Data.Functor.Identity
\end{minted}
\vspace{0.5mm}
\begin{minted}[xleftmargin=10pt]{haskell}
execute :: Compute Monad k v -> (k -> v) -> k -> Maybe v
execute compute store = fmap runIdentity . compute (pure . store)
\end{minted}
\vspace{1mm}

\noindent
Note that \hs{execute} can accept both an applicative as well as a \emph{monadic
compute} introduced in~\S\ref{sec-compute-monad}. Below we run \hs{execute} on
the above \hs{add} example. Note that \hs{execute} returns \hs{Nothing} for
inputs.

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
@\ghci@ store key = if key == "A1" then 10 else 20
@\ghci@ execute add store "A1"
Nothing
\end{minted}
\begin{minted}[xleftmargin=10pt]{haskell}
@\ghci@ execute add store "B1"
Just 30
\end{minted}

\subsection{Monadic compute}\label{sec-compute-monad}

As discussed in~\S\ref{sec-background}, some build tasks have dynamic
dependencies, which are determined by values of intermediate computations. In
our framework, such build tasks correspond to \emph{monadic compute}, i.e.
the type \hs{Compute}~\hs{Monad}~\hs{k}~\hs{v}. Recall the following spreadsheet
example:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{bash}
A1 = 10
A2 = 20
B1 = IF(C1=1,A1,A2)
C1 = 1
\end{minted}
\vspace{1mm}

\noindent
The task corresponding to the cell \cmd{B1} statically depends on \cmd{C1} and
dynamically depends on either \cmd{A1} or \cmd{A2}. We can express this using
our compute abstraction as follows\footnote{The spreadsheet example that uses
the \hs{INDIRECT} function can be expressed very similarly: simply replace the
last line of the \hs{select} function with \hs{fetch ("A" ++ show c1)}.}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
select :: Compute Monad String Integer
select fetch key | key /= "B1" = Nothing
                 | otherwise   = Just $ do
                     c1 <- fetch "C1"
                     if c1 == 1 then fetch "A1" else fetch "A2"
\end{minted}
\vspace{1mm}

We cannot statically analyse \hs{select} using the function \hs{dependencies}
from the previous section, but we can still \hs{execute} it on a given store:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
@\ghci@ store key = if key == "A1" then 10 else 20
@\ghci@ execute select store "B1"
Just 20
\end{minted}
\vspace{1mm}

\noindent
In the above execution $\cmd{C1} \neq 1$, hence the \hs{else} branch is taken.
To extract the dependencies of \hs{select} we introduce the function \hs{track}:
a combination of \hs{execute} and \hs{dependencies} that takes the store~\store
as input and computes both the resulting value and the list of its dependencies:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
import Control.Monad.Writer
\end{minted}
\vspace{0.5mm}
\begin{minted}[xleftmargin=10pt]{haskell}
track :: Compute Monad k v -> (k -> v) -> k -> Maybe (v, [k])
track compute store = fmap runWriter . compute (\k -> writer (store k, [k]))
\end{minted}
\vspace{1mm}

\noindent
The implementation uses the \hs{Writer} monad (\S\ref{sec-appendix-transformers}):
we feed \hs{fetch k = writer (store k, [k])} to the compute, which in addition
to fetching a value from the store, tracks the corresponding key. We can use
\hs{track} to track both applicative and monadic compute:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
@\ghci@ store key = if key == "A1" then 10 else 20
@\ghci@ track add store "B1"
Just (30,["A1","A2"])
\end{minted}
\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
@\ghci@ track select store "B1"
Just (20,["C1","A2"])
\end{minted}
\vspace{1mm}

\subsection{Build}\label{sec-general-build}

\todo{AM}{Provide a formal definition of `correctness', which does not rely on materialising intermediate values.}

\subsection{Free build structures}\label{sec-free-build}

\begin{minted}{haskell}
data Depend k v r = Depend [k] ([v] -> r)

data Depends k v r = Depends [k] ([v] -> Depends k v r)
                   | Done r
\end{minted}
