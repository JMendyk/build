\section{Build tasks, abstractly}\label{sec-compute}

This section presents purely functional abstractions that allow us to express
all the intricacies of build systems discussed in the previous
section~\S\ref{sec-background} and design complex build systems from simple
primitives. Specifically, we present the \emph{compute} and \emph{build}
abstractions:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
type Compute c k v = @\std{forall}@ f. c f => (k -> f v) -> k -> Maybe (f v)
type Build c i k v = Compute c k v -> k -> Maybe i -> (k -> v) -> (i, k -> v)
\end{minted}
\vspace{1mm}

\noindent
\hs{Compute} represents an abstract set of \emph{build tasks}, for example, build
rules in software build systems or formulas in spreadsheets. It is completely
isolated from the world of compilers, file systems, calculation chains, caches,
and all other complexities of real build systems. We explain the compute type
in~\S\ref{sec-general-compute}, and then discuss several noteworthy special
cases: functorial (\S\ref{sec-compute-functor}), applicative
(\S\ref{sec-compute-applicative}) and monadic (\S\ref{sec-compute-monad}) types
of compute.

\hs{Build} corresponds to the algorithm used for bringing a key-value store
\store to a consistent state by recomputing out-of-date values in an
appropriate order. We explain the build type and use it to develop a formal
definition of build systems in~\S\ref{sec-general-build}.
Sections~\S\ref{sec-build} and~\S\ref{sec-implementations} scrutinise the build
abstraction further and provide concrete implementations for several build
systems.

\subsection{Common vocabulary for build systems}
\label{sec-vocabulary}

We start by introducing a common vocabulary for build systems that allows
us to abstract away from specific application domains, such as software
development or spreadsheets. We will use this vocabulary throughout the rest of
the paper.

\emph{Keys} are used to distinguish \emph{values}. In software build systems,
keys are typically filenames, e.g.~\cmd{main.c}, whereas values are file
contents (a C program source code in this case). In spreadsheets, keys are cell
names, e.g. \cmd{A1}, and values are numbers, text, etc. that are typically
displayed inside cells. In Haskell code, we will use type variables \hs{k}
and \hs{v} to denote keys and values, respectively.

We use a cryptographic \emph{hash function} \hs{hash :: v -> Hash} for efficient
tracking and sharing of~build results, where \hs{Hash} is an abstract data type
equipped with the equality test.

A \emph{store} associates keys to values. It is convenient to assume that a
store is total function \store, i.e. it contains a value for every possible key.
We therefore also assume that the type of values is capable of encoding values
corresponding to non-existent keys (missing files or empty cells). This, in
particular, suggests that it is possible to \emph{depend on the absence of a
value}, which is a useful feature for build systems. In addition to usual
\hs{get} and \hs{put} operations, some stores support the \hs{getHash} operation
implemented more efficiently than by hashing the result of \hs{get}. For example,
GVFS (Git Virtual File System)~\cite{gvfs} stores file hashes and downloads file
contents only on demand -- an important feature for cloud build systems.

Some values must be provided by the user as \emph{input}. For example,
\cmd{main.c} can be edited by the user who relies on the build system to
compile it into \cmd{main.o} and subsequently \cmd{main.exe}. End build products,
such as \cmd{main.exe}, are \emph{output} values. All other values (in this case
\cmd{main.o}) are \emph{intermediate}; they are not interesting for the user
but are produced in the process of turning inputs into outputs.

\subsection{Compute}\label{sec-general-compute}

...
% \begin{figure}
% \begin{minted}{haskell}
% type Compute c k v = @\std{forall}@ f. c f => (k -> f v) -> k -> Maybe (f v)
% \end{minted}
% \caption{Compute abstractions}\label{fig-compute}
% \end{figure}
% Consider abstractions in Fig.~\ref{fig-compute}.

\subsection{Functorial compute}\label{sec-compute-functor}

The \emph{Collatz sequence} $C_i$ is defined as follows:

\[
C_{i} = {\begin{cases}~n&{\text{for }}i=0\\~f(C_{i-1})&{\text{otherwise}},\end{cases}}\hspace{12pt}\text{where}\hspace{12pt}f(k)={\begin{cases}~k/2&{\text{if }}k\text{ is even}\\~3k+1&{\text{otherwise}}\end{cases}}
\vspace{2mm}
\]
\noindent
and $n$ is a positive integer parameter. The famous \emph{Collatz conjecture}
states that the Collatz sequence eventually reaches 1 for all possible values of
$n$. For example, if $n=6$, we reach 1 in eight steps:
$(6, 3, 10, 5, 16, 8, 4, 2, 1, \dots)$, after which the sequence loops forever:
$(4, 2, 1, 4, 2, 1, \dots)$.

We can express the computation of values in the Collatz sequence as a functorial
compute:

\begin{minted}[xleftmargin=10pt]{haskell}
data Collatz = Collatz Int

collatz :: Compute Functor Collatz Int
collatz get (Collatz k) | k <= 0    = Nothing
                        | otherwise = Just $ f <$> get (Collatz (k - 1))
  where
    f n | even n    = n `div` 2
        | otherwise = 3 * n + 1
\end{minted}

...


\subsection{Applicative compute}\label{sec-compute-applicative}
The \emph{generalised Fibonacci sequence} $F_i$ is defined as follows:

\[
F_{i} = {\begin{cases}~n&{\text{for }}i=0\\~m&{\text{for }}i=1\\~F_{i-1}+F_{i-2}&{\text{otherwise}}\end{cases}}
\vspace{2mm}
\]
\noindent
where $n$ and $m$ are integer parameters. By setting $n=0$ and $m=1$ we obtain
the famous \emph{Fibonacci sequence}: $(0, 1, 1, 2, 3, 5, 8, 13, \dots$), and if
$n=2$ and $m=1$, the result is the \emph{Lucas sequence}:
$(2, 1, 3, 4, 7, 11, 18, 29, \dots)$.

We can express the computation of values in the generalised Fibonacci sequence
as an applicative compute:

\begin{minted}[xleftmargin=10pt]{haskell}
data Fibonacci = Fibonacci Int

fibonacci :: Compute Applicative Fibonacci Int
fibonacci get (Fibonacci k) | k <= 1    = Nothing
                            | otherwise = Just $ (+) <$> get (Fibonacci (k - 1))
                                                     <*> get (Fibonacci (k - 2))
\end{minted}

...

\label{getdependencies} We can define the dependencies for a \hs{Compute Applicative} using the \hs{Const} functor:

\begin{minted}{haskell}
getDependencies :: Compute Applicative k v -> k -> [k]
getDependencies comp = maybe [] getConst . comp (\k -> Const [k])
\end{minted}

\subsection{Monadic compute}\label{sec-compute-monad}

The \emph{Ackermann function} $A(m, n)$ is defined as follows:

\[
A(m, n) = {\begin{cases}~n+1&{\text{for }}m=0\\~A(m-1, 1)&{\text{for }}n=0\\~A(m-1,A(m,n-1))&{\text{otherwise}}\end{cases}}
\vspace{2mm}
\]
\noindent
We can express the computation of the Ackermann function as a monadic compute:

\begin{minted}[xleftmargin=10pt]{haskell}
data Ackermann = Ackermann Int Int

ackermann :: Compute Monad Ackermann Int
ackermann get (Ackermann m n)
    | m < 0 || n < 0 = Nothing
    | m == 0    = Just $ return (n + 1)
    | n == 0    = Just $ get (Ackermann (m - 1) 1)
    | otherwise = Just $ do
        index <- get (Ackermann m (n - 1))
        get (Ackermann (m - 1) index)
\end{minted}

...

\subsection{Build}\label{sec-general-build}

...

\todo{AM}{Turn the above into a formal definition of `correctness' and add a section that provides a mathematical definition of correctness, which does not rely on materialising intermediate values.}

\subsection{Free build structures}\label{sec-free-build}

\begin{minted}{haskell}
data Depend k v r = Depend [k] ([v] -> r)

data Depends k v r = Depends [k] ([v] -> Depends k v r)
                   | Done r
\end{minted}
