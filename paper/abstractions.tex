\clearpage

This paper presents a purely functional abstraction for build systems that
allows us to express all the above intricacies of build systems and design
complex build systems from simple primitives. The presented abstraction fits in
just two lines of Haskell code, which are explained
in~\S\ref{sec-abstractions}:

\begin{minted}{haskell}
type Compute c k v = @\std{forall}@ f. c f => (k -> f v) -> k -> Maybe (f v)
type Build c i k v = Compute c k v -> k -> Maybe i -> Map k v -> (i, Map k v)
\end{minted}


\section{Build systems, abstractly}\label{sec-abstractions}

In this section we present the \emph{compute} and \emph{build} abstractions:
\begin{itemize}
    \item Compute represents build rules (in build systems) or formulas (in
    spreadsheets), and is completely isolated from the world of compilers, file
    systems, memories, caches, and all other complexities of real build systems.
    \item Build corresponds to the algorithm used for bringing a key-value store
    to a coherent state by running compute.
\end{itemize}

\begin{figure}
\begin{minted}{haskell}
type Compute c k v = @\std{forall}@ f. c f => (k -> f v) -> k -> Maybe (f v)
\end{minted}
\caption{Compute abstractions}\label{fig-compute}
\end{figure}

Consider abstractions in Fig.~\ref{fig-compute}.

...

We now describe several types of build systems according to their constraint
on the functor \hs{f}.

...

