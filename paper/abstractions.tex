\section{Build systems, abstractly}\label{sec-abstractions}

This section presents purely functional abstractions for build systems that
allow us to express all the intricacies of build systems discussed in the
previous section~\S\ref{sec-background} and design complex build systems from
simple primitives. Specifically, we present the \emph{compute} and \emph{build}
abstractions:

\begin{minted}[xleftmargin=10pt]{haskell}
type Compute c k v = @\std{forall}@ f. c f => (k -> f v) -> k -> Maybe (f v)
type Build c i k v = Compute c k v -> k -> Maybe i -> Map k v -> (i, Map k v)
\end{minted}

\noindent
Compute represents build rules (in build systems) or formulas (in spreadsheets),
and is completely isolated from the world of compilers, file systems, memories,
caches, and all other complexities of real build systems. We explain the compute
type in~\S\ref{sec-compute}, and then discuss several noteworthy special cases:
functorial (\S\ref{sec-compute-functor}), applicative
(\S\ref{sec-compute-applicative}) and monadic (\S\ref{sec-compute-monad}) types
of compute.

Build corresponds to the algorithm used for bringing a key-value store to a
consistent state by recomputing dirty values in an appropriate order. We explain
the build type in~\S\ref{sec-build}, and then provide implementations for several
build systems in~\S\ref{sec-examples}.

\subsection{Compute}\label{sec-compute}

...
% \begin{figure}
% \begin{minted}{haskell}
% type Compute c k v = @\std{forall}@ f. c f => (k -> f v) -> k -> Maybe (f v)
% \end{minted}
% \caption{Compute abstractions}\label{fig-compute}
% \end{figure}
% Consider abstractions in Fig.~\ref{fig-compute}.

\subsection{Functorial compute}\label{sec-compute-functor}

The \emph{Collatz sequence} $C_i$ is defined as follows:

\[
C_{i} = {\begin{cases}~n&{\text{for }}i=0\\~f(C_{i-1})&{\text{otherwise}},\end{cases}}\hspace{12pt}\text{where}\hspace{12pt}f(k)={\begin{cases}~k/2&{\text{if }}k\text{ is even}\\~3k+1&{\text{otherwise}}\end{cases}}
\vspace{2mm}
\]
\noindent
and $n$ is a positive integer parameter. The famous \emph{Collatz conjecture}
states that the Collatz sequence eventually reaches 1 for all possible values of
$n$. For example, if $n=6$, we reach 1 in eight steps:
$(6, 3, 10, 5, 16, 8, 4, 2, 1, \dots)$, after which the sequence loops forever:
$(4, 2, 1, 4, 2, 1, \dots)$.

We can express the computation of values in the Collatz sequence as a functorial
compute:

\begin{minted}[xleftmargin=10pt]{haskell}
data Collatz = Collatz Int

collatz :: Compute Functor Collatz Int
collatz get (Collatz k) | k <= 0    = Nothing
                        | otherwise = Just $ f <$> get (Collatz (k - 1))
  where
    f n | even n    = n `div` 2
        | otherwise = 3 * n + 1
\end{minted}

...


\subsection{Applicative compute}\label{sec-compute-applicative}
The \emph{generalised Fibonacci sequence} $F_i$ is defined as follows:

\[
F_{i} = {\begin{cases}~n&{\text{for }}i=0\\~m&{\text{for }}i=1\\~F_{i-1}+F_{i-2}&{\text{otherwise}}\end{cases}}
\vspace{2mm}
\]
\noindent
where $n$ and $m$ are integer parameters. By setting $n=0$ and $m=1$ we obtain
the famous \emph{Fibonacci sequence}: $(0, 1, 1, 2, 3, 5, 8, 13, \dots$), and if
$n=2$ and $m=1$, the result is the \emph{Lucas sequence}:
$(2, 1, 3, 4, 7, 11, 18, 29, \dots)$.

We can express the computation of values in the generalised Fibonacci sequence
as an applicative compute:

\begin{minted}[xleftmargin=10pt]{haskell}
data Fibonacci = Fibonacci Int

fibonacci :: Compute Applicative Fibonacci Int
fibonacci get (Fibonacci k) | k <= 1    = Nothing
                            | otherwise = Just $ (+) <$> get (Fibonacci (k - 1))
                                                     <*> get (Fibonacci (k - 2))
\end{minted}

...

\subsection{Monadic compute}\label{sec-compute-monad}

The \emph{Ackermann function} $A(m, n)$ is defined as follows:

\[
A(m, n) = {\begin{cases}~n+1&{\text{for }}m=0\\~A(m-1, 1)&{\text{for }}n=0\\~A(m-1,A(m,n-1))&{\text{otherwise}}\end{cases}}
\vspace{2mm}
\]
\noindent
We can express the computation of the Ackermann function as a monadic compute:

\begin{minted}[xleftmargin=10pt]{haskell}
data Ackermann = Ackermann Int Int

ackermann :: Compute Monad Ackermann Int
ackermann get (Ackermann m n)
    | m < 0 || n < 0 = Nothing
    | m == 0    = Just $ return (n + 1)
    | n == 0    = Just $ get (Ackermann (m - 1) 1)
    | otherwise = Just $ do
        index <- get (Ackermann m (n - 1))
        get (Ackermann (m - 1) index)
\end{minted}

...

\subsection{Build}\label{sec-build}

...
