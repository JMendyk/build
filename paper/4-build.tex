\section{Build Systems \`a la Carte}\label{sec-build}

The focus of this paper is on a variety of implementations of
\hs{Build}~\hs{c}~\hs{i}~\hs{k}~\hs{v}, given
a \emph{client-supplied} implementation of \hs{Tasks}~\hs{c}~\hs{k}~\hs{v}. That
is, we are going to take \hs{Tasks} as given from now on, and explore variants of
\hs{Build}: first abstractly (in this section) and then concretely
in~\S\ref{sec-implementations}.

As per the definition of minimality~\ref{def-minimal}, a minimal build
system must \textbf{rebuild only out-of-date keys} and at most once. The only
way to achieve the ``at most once'' requirement while producing a correct build
result (\S\ref{sec-build-correctness}) is to \textbf{build all keys in an
order that respects their dependencies}.

\vspace{1mm}
We have bolded two different phrases above and, as we will see, the part of the
build system responsible for scheduling tasks in the dependency order
(a `scheduler') can be cleanly separated from the part responsible for deciding
whether a key needs to be rebuilt (a `rebuilder'). We therefore tackle each
aspect separately in subsections~\S\ref{sec-dependency-orderings}
and~\S\ref{sec-out-of-date}.

\subsection{Respecting the dependency order}
\label{sec-dependency-orderings}

The build systems overview (\S\ref{sec-background-summary}) highlighted three
distinct task schedulers respecting the dependency order. This subsection
explores their properties and possible implementations.

\vspace{-2mm}
\subsubsection{Topological}\label{sec-topological}

The topological scheduler pre-computes a linear order, which when followed,
ensures the build result is correct regardless of the initial store. Given a
task description and the output \hs{key}, you can compute the linear order by
first finding the (acyclic) graph of the \hs{key}'s reachable dependencies, and
then computing a topological sort. However, as we have seen in~\S\ref{sec-deps},
we can only extract dependencies from an applicative task, which requires the
build system to choose \hs{c}~\hs{=}~\hs{Applicative}, ruling out dynamic
dependencies.

\vspace{-2mm}
\subsubsection{Restarting}\label{sec-restarting}

The topological scheduler has two downsides: it is limited to \hs{Applicative}
build systems and requires a fresh topological sort each time. So, while the
actions themselves may be incremental (i.e. unnecessary tasks will not be
performed), the pre-processing is not. We can try to incrementalise the
topological sort by storing the topological order between build runs and assume
it to be correct, fixing it up if the build discovers any inconsistency, as
\Excel does.

This approach requires a way to abort tasks that have failed due to out-of-date
dependencies. It is also not minimal in the sense that a task may start, do some
meaningful work, and then abort. However, in the case of an \hs{Applicative}
system, that work is zero.

\Bazel's restarting scheduler does not store the topological order between build
runs; instead, it stores the most recent task dependency information. Since this
information may become outdated, \Bazel may also need to abort a task if a
newly discovered dependency is out-of-date.

\vspace{-2mm}
\subsubsection{Suspending}\label{sec-suspending}

An alternative approach, utilised by the \hs{busy} build system
(\S\ref{sec-general-build}) and \Shake, is to simply build dependencies when
they are requested, suspending the currently running task. By combining that
with tracking the keys that have already been built, one can obtain a minimal
build system with dynamic dependencies.

This approach requires that a task may be started and then suspended until
another task is complete. This can be done with cheap green threads and blocking
(the original approach of \Shake) or using continuation-passing style (what
\Shake does currently).

% An alternative approach to suspending a task is to abort
% it and restart it again later, at the cost of doing additional work.

\subsection{Determining out-of-date keys} \label{sec-out-of-date}

The second aspect, determining what to rebuild, can be addressed in one of four
fundamental ways, with a number of tweaks and variations within them.

\vspace{-2mm}
\subsubsection{A dirty bit}\label{sec-dirty-bit}

The idea of a dirty bit is to have one piece of persistent
information per key, saying whether the key is
\emph{dirty} or \emph{clean}. After a build, all bits are set to clean. When the
next build starts, anything that changed between the two states is marked
dirty.
% ; and by marking additional things dirty/clean the build system can track
% what needs to rebuild.
When reaching a key, if it and all its transitive dependencies are clean, the
key does not need recomputing.

\Excel models the dirty bit approach most directly, having an actual dirty bit
associated with each cell, marking the cell dirty if the user modifies it.
When rebuilding, if a cell only depends on clean cells it is skipped, otherwise
it is rebuilt and marked dirty so that the cells that depend on it are
subsequently rebuilt too.

% AM: I didn't understand this bit, so commented it out.
% The only wrinkle in this scheme is that \Excel supports
% monadic tasks, and does not separately record the rebuilt, so it has
% to approximate in this case.

\Make uses file modification times, and compares files to their
dependencies, which can be thought of as a dirty bit which is set when
a file is newer than its dependencies. The interesting property of
this dirty bit is that it is not under the control of \Make; rather it is
existing file-system information that has been repurposed. In particular,
modifying a file automatically clears its dirty bit, and
automatically sets the dirty bit of the nodes depending on it. One
thing \Make does require is that file timestamps only go forward in
time -- something that can be violated by backup software.

When using a dirty bit, it is necessary to check all the dependencies of a key.
For applicative build systems that list is easy to obtain, but for monadic
build systems there is no general way to get all dependencies. Instead \Excel
computes a \emph{static approximation} of the dependencies. For applicative
tasks that approximation is correct. For functions such as \cmd{IF} it marks the
cell dirty if \emph{any} potential dependency has changed, even on the untaken
\emph{if} branch. For functions such as \cmd{INDIRECT} whose dependencies cannot
be guessed, it conservatively assumes the dependencies have always changed.

With a dirty bit it is simple to achieve minimality. However, to achieve early cutoff
(\S\ref{sec-background-shake}) it would be important to not set the dirty bit
after a computation that did not change the value. \Excel could use this
approach, but does not. In contrast, \Make cannot implement early cutoff nicely -- to
do so it would have to mark the node clean (so it would not rebuild in the next
run) and at the same time not mark the things it depends on dirty -- an
impossible task with only the ability to update to the latest modification time.
\Make can approximate early cutoff by not modifying the result file, and not marking it clean,
but then it will rerun in every subsequent build.

\vspace{-2mm}
\subsubsection{Verifying traces}\label{sec-verifying-traces}

An alternative way to determine if a key is dirty is to record what state the
values/hashes of dependencies were used at last time, and if something has
changed, the key is dirty and must be recomputed -- in essence a \emph{trace}
which we can use to \emph{verify} existing values. For traces, there are two essential
operations -- adding a new value to the trace store, and using the traces to determine if something needs
rebuilding. Assuming a store of verifying traces \hs{VT}~\hs{k}~\hs{v}, the operations are:

\begin{minted}{haskell}
recordVT :: k -> Hash v -> [(k, Hash v)] -> VT k v -> VT k v
verifyVT :: (Monad m, Eq k, Eq v)
         => k -> Hash v -> (k -> m (Hash v)) -> VT k v -> m Bool
\end{minted}

We assume that \hs{Hash}~\hs{v} is a small constant size, constructed from hashing the
underlying \hs{v} rather than storing it directly. After successfully building a key, we call \hs{recordVT} passing the key, the hash of its value, and the list of hashes and dependencies. Combined with the existing set of verifying traces, that provides a new set of verifying traces.

More interestingly, to \emph{verify} whether a key needs rebuilding we supply the key and the hash of the current result in the store, along with a function for obtaining the post-build result of any key (using whatever ordering strategy
as per \S\ref{sec-dependency-orderings}), and the existing \hs{VT} information. The result will be a \hs{Bool} where \hs{True} indicates that the trace could be verified, or \hs{False} to indicate the key should be rebuilt.

One potential implementation would be to record all arguments passed to \hs{recordVT}, and verify by simply checking if any argument matches the information passed by \hs{verifyVT} (we discuss smarter implementations in~\S\ref{sec-smart-traces}).

\subsubsection{Constructive traces}\label{sec-constructive-traces}

A verifying trace allows us to mark a key dirty and rebuild it. Extending that information we can store a \emph{constructive} trace which is the trace plus the actual result. Once we are storing the complete result it makes sense to record many constructive traces per key, and to share them with other users, providing cloud-build functionality. We can represent this additional information by providing the operations:

\begin{minted}{haskell}
recordCT :: k -> v -> [(k, Hash v)] -> CT k v -> CT k v
constructCT :: (Monad m, Eq k, Eq v) => k -> (k -> m (Hash v)) -> CT k v -> m [v]
\end{minted}

The function \hs{recordCT} looks like \hs{recordVT}, but instead of just passing the hash of the result, we require the whole result. The \hs{verifyVT} has been replaced with \hs{constructCT}, which instead of taking the hash of the value, instead returns a list of suitable values. If the current value in the store matches one of the possible values, the build can skip this rule. If the resulting list is empty, the build must rerun. However, if the current value does not match the store, and there is a possible value, we can use any value from the constructive list \emph{without} doing any work to compute it.

\subsubsection{Deterministic constructive traces}\label{sec-deterministic-constructive-traces}

If we assume all actions are \emph{deterministic} (specifically that given the same inputs they produce the same output) then we can make a further optimisation to arrive at deterministic constructive traces:

\begin{minted}{haskell}
data Trace k v = Trace
    { key     :: k
    , depends :: [(k, Hash (Tree (Hash v)))]
    , result  :: v
    }
\end{minted}

Instead of storing the hash of the immediate dependencies, a determinstic constructive trace only ever takes the hash of initial inputs. To form the hash of a dependency, it forms the tree of dependencies all the way to the inputs, and hashes that. As an example, if \hs{a} depends on the input \hs{b}, then the dependency value used for \hs{a} uses \hs{hash}~\hs{b}, \emph{but not} \hs{hash}~\hs{a}. As a consequence, given the hashes of all inputs, and dependency information (e.g. from an \hs{Applicative} constraint) it is possible to compute the dependency hash of \emph{any} node, without having built any intermediate nodes. This property is particularly useful for ``shallow builds'', as discussed in~\S\ref{sec-cloud-aspects}.

\subsection{Smarter \hs{[Trace]} data structures}\label{sec-smart-traces}

In the examples above, we have used \hs{[Trace}~\hs{k}~\hs{v]} to capture a list
of traces~--~however, using a list necessarily means that finding the right trace
takes $O(n)$. For each of the \hs{Trace} based systems it is possible to devise
a smarter representation, which we sketch below. Note that these implementations
do not avoid calls to \hs{compute}, merely overheads in the build system itself.

\begin{minted}{haskell}
data Trace k v = Trace
    { key     :: k
    , depends :: [(k, Hash v)]
    , result  :: Hash v }
\end{minted}

\begin{enumerate}
\item Any system using verifying traces, e.g. \Shake, is unlikely to see significant benefit from storing more than one \hs{Trace} per key\footnote{There is a small chance of a benefit if the dependencies change but the result does not, and then the dependencies change back to what they were before.}. Therefore, such systems can store \hs{Map}~\hs{k}~\hs{(Trace}~\hs{k}~\hs{v)}, where the initial \hs{k} is the \hs{key} field of \hs{Trace}.
\item Any system using \hs{Applicative} dependencies can omit the dependency keys from the \hs{Trace} as they can be recovered from the \hs{key} field.
\item Any \hs{Applicative} build system storing constructive traces, e.g. \Bazel, can index directly from the key and results to the output result~--~i.e. \hs{Map}~\hs{(@@k,}~\hs{[Hash}~\hs{v])}~\hs{v}. Importantly, assuming the traces are stored on a central server, the client can compute the key and the hashes of its dependencies, then make a single call to the server to retrieve the result.
\item Many cloud build systems store hashes of values in the trace information, then have a separate ``blob server'' which associates hashes with their actual contents.
\item Finally, a \hs{Monad} build system with constructive traces can be stored as \hs{Map}~\hs{k}~\hs{(Choice}~\hs{k}~\hs{v)}, assuming a definition of \hs{Choice} as:
\begin{minted}[xleftmargin=10pt]{haskell}
data Choice k v = Choice k (Map (Hash v) (Choice k v))
                | Result (Hash v)
\end{minted}
Here the \hs{Choice} encodes a tree, asking successive questions about keys, and taking different branches based on the answers, until it reaches a final result. Implementing this structure over client-server communication requires either a chatty interface with lots of round-trips per \hs{Choice} step, or sending over a part of the tree that is not subsequently explored.
\end{enumerate}

\subsection{Build Systems \`a la Carte}\label{sec-design-space}

\begin{table}[h]
\smaller
\centering
\begin{tabular}{l||c|c|c}
\hline
Property           & Topological\hspace{2mm}\S\ref{sec-topological} & Restarting\hspace{2mm}\S\ref{sec-restarting} & Suspending\hspace{2mm}\S\ref{sec-suspending}    \\\hline
\hline
Dirty bit\hfill\S\ref{sec-dirty-bit}                                                             & \Make       & \Excel & -              \\\hline
Verifying traces\hfill\S\ref{sec-verifying-traces}                                               & \Ninja      & -      & \Shake         \\\hline
Constructive traces\hspace{2mm}\hfill\S\ref{sec-constructive-traces}                             & \CloudBuild & \Bazel & -              \\\hline
Deterministic constructive traces\hspace{2mm}\hfill\S\ref{sec-deterministic-constructive-traces} & \Buck       & -      & \Nix           \\\hline
\end{tabular}
\vspace{2mm}
\caption{Build systems \`a la carte.\label{tab-build-systems}}
\vspace{-2mm}
\end{table}

With the information in this section we can build a table comparing the
dependency order strategy with the out-of-date keys strategy, providing 12~possible
build systems, 8~of which are actually inhabited by existing build systems
(we discuss all these systems in \S\ref{sec-related-build}). Of the
remaining 4~spots, all result in workable build systems. The most interesting
unfilled spot in the table is suspending constructive traces, which would provide
many benefits, and which we title \Cloud \Shake (as we plan on extending \Shake to occupy that spot)
and further explore further in~\S\ref{sec-implementation-cloud}.
