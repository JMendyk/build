\section{Build systems, abstractly}\label{sec-build}

In this section we describe our \hs{Build} abstraction, defined as:

\begin{minted}{haskell}
type Build c i k v = Compute c k v -> k -> Maybe i -> (k -> v) -> (i, k -> v)
\end{minted}

The build function takes 4 type arguments: \hs{c} is the constraint used for \hs{Compute} (typically either \hs{Applicative} or \hs{Monad}), \hs{i} is the information stored by the build system and \hs{k}/\hs{v} are the key/value types as described in \S\ref{sec-vocabulary}. Given a build system \hs{build}:

\begin{minted}{haskell}
build compute key info store = (info', store')
    where ...
\end{minted}

The function \hs{build} is responsible for ensuring that \hs{key} and its dependencies are up-to-date in \hs{store'} starting from \hs{store}. As part of that work, the \hs{build} function \textit{may} store other information in \hs{info'}, which will be provided as \hs{info} in future calls to \hs{build}. The \hs{info} parameter will be \hs{Nothing} on the very first call to \hs{build}. We assume that \hs{store} is total, where "missing files" can be represented by some sentinel value of \hs{v} if necessary.

All the \hs{Build} types we define are polymorphic in both \hs{k} and \hs{v} (perhaps adding constraints to them), and have specific instantiations of \hs{c} and \hs{i}. How to implement \hs{Build} can be captured by the idea:

\begin{quote}
A build system must build \underline{out-of-date keys} while \underline{respecting dependency orderings}.
\end{quote}

We have underlined two different phrases in this sentence, and tackle each aspect separately.


\subsection{Respecting dependency orderings}
\label{sec-dependency-orderings}

If the \hs{Compute} function for \hs{k} calls the functional argument of \hs{d} then the build system is responsible for ensuring that \hs{d} is built \textit{before} \hs{k}. Looking at the build systems in \S\ref{sec-background} we have observed 3 distinct approaches to respecting dependency orderings. In this section of the paper we'll explore what properties are a consequence and how they operate.

\subsubsection{Topological sort}

The topological approach creates a linear ordering, which when followed, ensures each build is correct. Given a function from a key to its dependencies, and an initial key, you can compute the linear ordering by first taking the transitive closure, then doing a topological sort. However, to go from a \hs{Compute} to the dependencies, it must be the case that the constraint is \hs{Applicative}, as per \S\ref{sec-deps}.

\subsubsection{Reordering}

The topological sort approach has two downside - it is limited to \hs{Applicative} build systems and requires a fresh topological sort each time - while the actions themselves may be incremental the pre-processing is not. An alternative approach is to keep the topological order between runs and assume it to be correct, but if execution determines it is wrong, reorder.

This requires a way to abort computations that have failed. It's also not minimal in the sense that computations start, may do some meaningful work, then abort. However, in the case of an \hs{Applicative} system, that work is zero. It does require the ability to terminate a running computation.

\subsubsection{Recursive}

An alternative way is to simply build dependencies when they are requested. By combining that with a transient store of which keys have been built in this execution, you can describe dependencies in a simple way. You need a way to suspend a running action, which can be done with cheap green-threads and blocking (the original approach of Shake) or with a continuation-passing style (what Shake does now). An alternative approach to suspending a computation is to abort it and restart it again later, at the cost of doing additional work.

\subsection{Determining what is out-of-date}

The second part, determining what to rebuild, can be addressed in one of three fundamental ways, with a number of tweaks and variations within them.

\subsubsection{A dirty bit}
\label{sec-dirty-bit}

The idea of a dirty bit is to have one piece of information, whether a key is dirty or clean. After a run, all bits are set to clean. When a run starts anything that changed between the two states is marked dirty - by marking additional things dirty/clean the build system can track what needs to rebuild. When reaching a key, if it and all its dependencies are clean, the key does not need recomputing.

\Excel models the dirty bit approach most directly, having an actual dirty bit associated with each cell. Since Excel is the only manner by which a cell may be changed by the user, it can dirty the bits as necessary. When rebuilding if a cell only depends on clean cells it is skipped, otherwise it is rebuilt and marked dirty itself. The only wrinkle in this scheme is that \Excel supports monadic build systems, and does not separately record what rebuilt, so it has to approximate in this case.

\Make uses file modification times, and compares files to their dependencies, which can be thought of as a dirty bit which is set when a file is newer than its dependencies. The interesting property of this dirty bit is that it is not under control of \Make, but an existing bit that is repurposed. In particular, updating a file automatically clears its dirty bit, and automatically sets the dirty bit of the nodes depending on it. One thing \Make does require is that file timestamps only go forward in time - something that can be violated by some backup software.

With a dirty bit it is possible to achieve minimality. To achieve cut-off it would be important to not set the dirty bit after a computation that did not change the value. \Excel could model this approach, but does not. In contrast, \Make cannot model cut-off - to do so it would have to mark the node clean (so it didn't rebuild in the next run) and at the same time not mark the things it depends on dirty - an impossible task with only the ability to update to the latest modification time.

\subsubsection{Verifying traces}\label{sec-verifying-traces}

An alternative way to determine if a key is dirty is to record what state the values/hashes of dependencies were used at last time, and if something has changed, the key is dirty and must be recomputed - in essence a trace with which we can use to \textit{verify} existing values. We can describe a trace as:

\begin{minted}{haskell}
data Trace k v = Trace
    {key :: k
    ,dependencies :: [(k, Hash v)]
    ,result :: Hash v
    }
\end{minted}

We assume that \hs{Hash v} is a small constant size, constructed from hashing the underlying \hs{v} rather than storing it directly. Checking a trace requires ensuring all the dependencies are up-to-date (using whatever ordering strategy as per \S\ref{sec-dependency-orderings}), then comparing if the dependencies are same as the current value and that the result is the same. After computing a fresh value we add its \hs{Trace} to the list. Therefore the information stored by a build system that verifies traces is \hs{[Trace k v]}.

\subsubsection{Constructive traces}\label{sec-constructive-traces}

A verifying trace allows us to mark a key dirty and rebuild it. Extending that information we can store a \textit{constructive} trace which is the trace plus the actual result. Once we are storing the complete result it makes sense to record many constructive traces per key, and to share them with other users, providing cloud-build functionality. We can represent that as:

\begin{minted}{haskell}
data Traces k v = Traces
    {traces :: [Trace k v]
    ,contents :: Map (Hash v) v
    }
\end{minted}

We have a list of traces, plus a \hs{Map} from the hash to the actual contents. Checking a trace is the same as before, but if the result is the only thing that is different we can simply retrieve a fresh result from \hs{contents} \textit{without} recomputing it.

For both verifying and constructive choices it is possible to choose smarter data structures than simply a list of \hs{Trace}, which we discuss in \S\ref{sec-smart-traces}.

\todo{AM}{AM: I would also like to see an actual \hs{upToDate} function for verifying, and a \hs{recreate} for `recreating'. NM: It actually gets a bit more confusing than that - since you end up needing to pass functions to get yourself, your dependencies etc. Unclear there is a win. The functions would occur in the next section anyway.}
