\section{Build Systems \`a la Carte}\label{sec-build}

The focus of this paper is on a variety of implementations of \hs{Build}, given
a client-supplied implementation of \hs{Task}. That is, we are going to take
\hs{Task} as given from now on, and explore \hs{Build} variants: first
abstractly (in this section) and then concretely in~\S\ref{sec-implementations}.

Let \hs{result}~\hs{=}~\hs{build}~\hs{task}~\hs{key}~\hs{store}. The build
system \hs{build} is responsible for ensuring that \hs{key} and its dependencies
are up-to-date in \hs{result} starting from \hs{store} (see the formal definition
of correctness in~\S\ref{sec-build-correctness}). As part of that work,
\hs{build} \emph{may} store auxiliary information \hs{info} of type \hs{i} in
the \hs{store}, which will be provided to future calls of \hs{build}.

All the build systems we define are polymorphic in both \hs{k} and \hs{v}
(perhaps adding constraints to them), and have specific instantiations of \hs{c}
and \hs{i}. As an example, recall that the \hs{busy} build system defined
in~\S\ref{sec-general-build}, has \hs{c}~\hs{=}~\hs{Monad}, i.e. it supports
monadic tasks, and \hs{i = ()}, i.e. it does not store any build information.

According to the definition of minimality~\ref{def-minimal}, a minimal build
system must \textbf{rebuild only out-of-date keys} and at most once. The only
way to achieve the ``at most once'' requirement is to \textbf{build all keys in
the order that respects their dependencies}.

We have emphasised two different phrases above, and tackle each aspect separately.

\subsection{Respecting the dependency order}
\label{sec-dependency-orderings}

The build systems overview (\S\ref{sec-background-summary}) highlighted three
distinct approaches to respecting the dependency order. This subsection explores
their properties and possible implementations.

\subsubsection{Topological}

The topological approach computes a linear order, which when followed, ensures
the \hs{build} is correct regardless of the initial \hs{store}. Given a function
from a key to its dependencies, and the output \hs{key}, you can compute the
linear order by first taking the transitive closure of \hs{key}'s dependencies,
and then computing its topological sort. However, as we have seen
in~\S\ref{sec-deps}, we can only extract dependencies from an applicative task,
which requires the build system to choose \hs{c}~\hs{=}~\hs{Applicative}, ruling
out dynamic dependencies.

\subsubsection{Reordering}

The topological approach has two downsides: it is limited to \hs{Applicative}
build systems and requires a fresh topological sort each time -- while the
actions themselves may be incremental the pre-processing is not. An alternative
approach is to store the topological order between build runs and assume it to
be correct, but if the build determines it is wrong, reorder.

This requires a way to abort tasks that have failed due to out-of-date
dependencies. It is also not minimal in the sense that tasks start, may do some
meaningful work, then abort. However, in the case of an \hs{Applicative} system,
that work is zero.

\subsubsection{Recursive}

An alternative approach, utilised by the \hs{busy} build system
(\S\ref{sec-general-build}) is to simply build dependencies when they are
requested. By combining that with a transient store of which keys have already
been built, you can obtain a minimal build system.

This requires a way to suspend a running task, which can be done with cheap
green threads and blocking (the original approach of \Shake) or with a
continuation-passing style (what \Shake does now). An alternative approach to
suspending a task is to abort it and restart it again later, at the cost
of doing additional work.

\subsection{Determining out-of-date keys}

The second aspect, determining what to rebuild, can be addressed in one of three
fundamental ways, with a number of tweaks and variations within them.

\subsubsection{A dirty bit}\label{sec-dirty-bit}

The idea of a dirty bit is to have one piece of information, whether a key is
\emph{dirty} or \emph{clean}. After a build, all bits are set to clean. When the
next build starts anything that changed between the two states is marked
dirty~--~by marking additional things dirty/clean the build system can track
what needs to rebuild. When reaching a key, if it and all its dependencies are
clean, the key does not need recomputing.

\Excel models the dirty bit approach most directly, having an actual dirty bit
associated with each cell. Since \Excel is the only manner by which a cell may
be changed by the user, it can mark cells dirty as necessary. When rebuilding,
if a cell only depends on clean cells it is skipped, otherwise it is rebuilt and
marked dirty itself.

% AM: I didn't understand this bit, so commented it out.
% The only wrinkle in this scheme is that \Excel supports
% monadic tasks, and does not separately record the rebuilt, so it has
% to approximate in this case.

\Make uses file modification times, and compares files to their dependencies,
which can be thought of as a dirty bit which is set when a file is newer than
its dependencies. The interesting property of this dirty bit is that it is not
under control of \Make, but an existing bit that is repurposed. In particular,
rebuilding a file automatically clears its dirty bit, and automatically sets
the dirty bit of the nodes depending on it. One thing \Make does require is that
file timestamps only go forward in time -- something that can be violated by
backup software.

With a dirty bit it is possible to achieve minimality. To achieve early cutoff
(\S\ref{sec-background-shake}) it would be important to not set the dirty bit
after a computation that did not change the value. \Excel could model this
approach, but does not. In contrast, \Make cannot model early cutoff -- to do so
it would have to mark the node clean (so it didn't rebuild in the next run) and
at the same time not mark the things it depends on dirty -- an impossible task
with only the ability to update to the latest modification time.

\subsubsection{Verifying traces}\label{sec-verifying-traces}

An alternative way to determine if a key is dirty is to record what state the
values/hashes of dependencies were used at last time, and if something has
changed, the key is dirty and must be recomputed -- in essence a \emph{trace}
which we can use to \textit{verify} existing values. We can describe a trace as:

\todo{AM/NM}{Change from \hs{[Trace k v]} to \hs{Map k (Trave k v)} or something
similar, so that it's obvious we have one trace per key .}

\begin{minted}{haskell}
data Trace k v = Trace
    { key          :: k
    , dependencies :: [(k, Hash)]
    , result       :: Hash }
\end{minted}

We assume that \hs{Hash} is a small constant size, constructed from hashing the
underlying \hs{v} rather than storing it directly. Checking a trace requires
ensuring all the dependencies are up-to-date (using whatever ordering strategy
as per \S\ref{sec-dependency-orderings}), then comparing if the dependencies are
same as the current value and that the result is the same. After computing a
fresh value we add its \hs{Trace} to the list. Therefore the information stored
by a build system that verifies traces is \hs{[Trace k v]}.

\subsubsection{Constructive traces}\label{sec-constructive-traces}

A verifying trace allows us to mark a key dirty and rebuild it. Extending that information we can store a \textit{constructive} trace which is the trace plus the actual result. Once we are storing the complete result it makes sense to record many constructive traces per key, and to share them with other users, providing cloud-build functionality. We can represent that as:

\todo{AM/NM}{Traces -- why the indirection (first get the hash, then look it up)?
Can we drop it? Can we switch to a more efficient/explicit data structure than a list?}

\begin{minted}{haskell}
data Traces k v = Traces
    { traces :: [Trace k v]
    , cache  :: Map Hash v }
\end{minted}

We have a list of traces, plus a \hs{Map} from the hash to the actual contents. Checking a trace is the same as before, but if the result is the only thing that is different we can simply retrieve a fresh result from \hs{cache} \textit{without} recomputing it.

For both verifying and constructive choices it is possible to choose smarter data structures than simply a list of \hs{Trace}, which we discuss in \S\ref{sec-smart-traces}.

\todo{AM}{AM: I would also like to see actual \hs{verify} and \hs{construct} functions.

NM: It actually gets a bit more confusing than that - since you end up needing to pass functions to get yourself, your dependencies etc. Unclear there is a win. The functions would occur in the next section anyway.

AM: Now, after we've switched to \hs{Store i k v} it might work better?}
