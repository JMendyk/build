\section{Build Systems \`a la Carte}\label{sec-build}

The focus of this paper is on a variety of implementations of
\hs{Build}~\hs{c}~\hs{i}~\hs{k}~\hs{v}, given
a \emph{client-supplied} implementation of \hs{Task}~\hs{c}~\hs{k}~\hs{v}. That
is, we are going to take \hs{Task} as given from now on, and explore variants of
\hs{Build}: first abstractly (in this section) and then concretely
in~\S\ref{sec-implementations}.

As per the definition of minimality~\ref{def-minimal}, a minimal build
system must \underline{rebuild only out-of-date keys} and at most once. The only
way to achieve the ``at most once'' requirement while producing a correct build
result (\S\ref{sec-build-correctness}) is to \underline{build all keys in the
order that respects their dependencies}.

\vspace{1mm}
We have underlined two different phrases above, and tackle each aspect separately.

\subsection{Respecting the dependency order}
\label{sec-dependency-orderings}

The build systems overview (\S\ref{sec-background-summary}) highlighted three
distinct approaches to respecting the dependency order. This subsection explores
their properties and possible implementations.

\subsubsection{Topological}

The topological approach pre-computes a linear order, which when followed, ensures
the \hs{build} is correct regardless of the initial \hs{store}. Given a function
from a key to its dependencies, and the output \hs{key}, you can compute the
linear order by first taking the transitive closure of \hs{key}'s dependencies,
and then computing its topological sort. However, as we have seen
in~\S\ref{sec-deps}, we can only extract dependencies from an applicative task,
which requires the build system to choose \hs{c}~\hs{=}~\hs{Applicative}, ruling
out dynamic dependencies.

\subsubsection{Reordering}

The topological approach has two downsides: it is limited to \hs{Applicative}
build systems and requires a fresh topological sort each time.  So, while the
actions themselves may be incremental (i.e. unnecessary tasks will not be performed),
the pre-processing is not. We may try to incrementalise the topological sort by
storing the topological order between build runs and assume it to
be correct, but if the build determines it is wrong, fix it up.

This requires a way to abort tasks that have failed due to out-of-date
dependencies. It is also not minimal in the sense that a task may start, do some
meaningful work, then abort. However, in the case of an \hs{Applicative} system,
that work is zero.

\subsubsection{Recursive}

An alternative approach, utilised by the \hs{busy} build system
(\S\ref{sec-general-build}), is to simply build dependencies when they are
requested. By combining that with a transient log of which keys have already
been built, you can obtain a minimal build system.

This requires a way to suspend a running task, which can be done with cheap
green threads and blocking (the original approach of \Shake) or with a
continuation-passing style (what \Shake does now). An alternative approach to
suspending a task is to abort it and restart it again later, at the cost
of doing additional work.

\subsection{Determining out-of-date keys} \label{sec-out-of-date}

The second aspect, determining what to rebuild, can be addressed in one of three
fundamental ways, with a number of tweaks and variations within them.

\subsubsection{A dirty bit}\label{sec-dirty-bit}

The idea of a dirty bit is to have one piece of persistent
information per key, saying whether the key is
\emph{dirty} or \emph{clean}. After a build, all bits are set to clean. When the
next build starts, anything that changed between the two states is marked
dirty.
% ; and by marking additional things dirty/clean the build system can track
% what needs to rebuild.
When reaching a key, if it and all its transitive dependencies are clean, the
key does not need recomputing.

\Excel models the dirty bit approach most directly, having an actual dirty bit
associated with each cell, marking the cell dirty if the user modifies it.
When rebuilding, if a cell only depends on clean cells it is skipped, otherwise
it is rebuilt and is marked dirty so that the cells that depend on it are
subsequently rebuilt too.

% AM: I didn't understand this bit, so commented it out.
% The only wrinkle in this scheme is that \Excel supports
% monadic tasks, and does not separately record the rebuilt, so it has
% to approximate in this case.

\Make uses file modification times, and compares files to their
dependencies, which can be thought of as a dirty bit which is set when
a file is newer than its dependencies. The interesting property of
this dirty bit is that it is not under control of \Make; rather it is
existing file-system information that is repurposed. In particular,
rebuilding a file automatically clears its dirty bit, and
automatically sets the dirty bit of the nodes depending on it. One
thing \Make does require is that file timestamps only go forward in
time -- something that can be violated by backup software.

With a dirty bit it is possible to achieve minimality. To achieve early cutoff
(\S\ref{sec-background-shake}) it would be important to not set the dirty bit
after a computation that did not change the value. \Excel could use this
approach, but does not. In contrast, \Make cannot implement early cutoff -- to
do so it would have to mark the node clean (so it would not rebuild in the next
run) and at the same time not mark the things it depends on dirty -- an
impossible task with only the ability to update to the latest modification time.

\todo{NM}{I stopped here, as the traces seem not finalised yet.}

\subsubsection{Verifying traces}\label{sec-verifying-traces}

An alternative way to determine if a key is dirty is to record what state the
values/hashes of dependencies were used at last time, and if something has
changed, the key is dirty and must be recomputed -- in essence a \emph{trace}
which we can use to \emph{verify} existing values. We can describe a trace as:

\begin{minted}{haskell}
data Trace k v = Trace
    { key          :: k
    , dependencies :: [(k, Hash v)]
    , result       :: Hash v }
\end{minted}

We assume that \hs{Hash v} is a small constant size, constructed from hashing the
underlying \hs{v} rather than storing it directly. Checking a trace requires
ensuring all the dependencies are up to date (using whatever ordering strategy
as per \S\ref{sec-dependency-orderings}), then comparing if the dependencies are
same as the current value and that the result is the same. After computing a
fresh value we add its \hs{Trace k v} to the list. Therefore the information stored
by a build system that verifies traces is \hs{[Trace k v]}.

\todo{NM}{We need to emphasise that lists are convenient for expressing the semantics,
but actual implementation uses a data structure optimised for a specific build system.}

\subsubsection{Constructive traces}\label{sec-constructive-traces}

A verifying trace allows us to mark a key dirty and rebuild it. Extending that information we can store a \emph{constructive} trace which is the trace plus the actual result. Once we are storing the complete result it makes sense to record many constructive traces per key, and to share them with other users, providing cloud-build functionality. We can represent that as:

\todo{NM}{Clarify why the indirection (first get the hash, then look it up)?}

\begin{minted}{haskell}
data Traces k v = Traces
    { traces :: [Trace k v]
    , cache  :: Map Hash v }
\end{minted}

We have a list of traces, plus a \hs{Map} from the hash to the actual contents. Checking a trace is the same as before, but if the result is the only thing that is different we can simply retrieve a fresh result from \hs{cache} \emph{without} recomputing it.

For both verifying and constructive choices it is possible to choose smarter data structures than simply a list of \hs{Trace}, which we discuss in \S\ref{sec-smart-traces}.

\subsection{Summary}\label{sec-design-space}

\todo{NM}{Check the table and add a decription.}

\begin{table}[h]
\smaller
\centering
\begin{tabular}{l||c|c|c}
\hline
Property           & Topological & Reordering & Recursive    \\\hline
\hline
Dirty bit          & \Make                   & \Excel                   & \Shake without early cutoff \\\hline
Verifying trace    & \Make with early cutoff & \Excel with early cutoff & \Shake                      \\\hline
Constructive trace & \Bazel                  & Cloud \Excel             & Cloud \Shake                \\\hline
\end{tabular}
\vspace{0.5mm}
\caption{Build systems \`a la carte.\label{tab-build-systems}}
\end{table}
