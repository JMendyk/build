\section{Experience}\label{sec-experience}

As a set of authors, we've written a paper about the \Shake build system \cite{mitchell2012shake},
applying \Shake to building GHC \cite{hadrian}, and a paper about the categorisation of build
systems \cite{mokhov2018buildsystems}. The original motivation of the research in that final paper was to create
``Cloud Shake'', and use it for the GHC build system. In this section we tie these papers together,
reflecting on our experience since these papers.

\subsection{Experience from \Shake}

The original design of \Shake hasn't changed since the initial paper. Since that paper there have been roughly 5,000 commits to the \Shake project\footnote{\url{https://github.com/ndmitchell/shake}}. They add concepts like resources (if two rules content from a single external resource), rewrite serialisation to be faster, documentation including a website\footnote{\url{https://shakebuild.com}}, and add lots of tests. The biggest change in that time period was moving from blocking threads to continuations for the suspending scheduler. The most visible change is switching \hs{*>} for \hs{\%>}\footnote{A conflicting \hs{*>} operator was added to the Haskell \hs{Prelude}.}, but almost all external and internal details remain the same.

We consider the lack of change to suggest that \Shake is based on fundamental principles -- principles we can now name and describe as a consequence of \cite{mokhov2018buildsystems}. There are two main aspects of the original \Shake paper \cite{mitchell2012shake} that are described more clearly in this paper, the first is the rebuilder, which is described as verifying step traces in \S\ref{sec-step-traces}. The second is the power of \Shake tasks (called actions in the original paper. Originally these tasks were described as being equivalent to:

\begin{minted}[xleftmargin=10pt]{haskell}
data Action k v = Finished v
                | Depends v (v -> Action)
\end{minted}

In some sense this is the ``free'' version of the \hs{Task Monad} -- the two types form an isomorphism. Similary, \Make tasks were described as equivalent to

\begin{minted}[xleftmargin=10pt]{haskell}
data Rule k v = Rule {depends :: [k], action :: [v] -> v}
\end{minted}

Once again, this type is isomorphism to \hs{Task Applicative}. By describing these types using \hs{Task} we are able to pinpoint the differences (\hs{Monad} vs \hs{Applicative}) and use existing literature to prove what is and isn't possible.

\subsection{Experience from building GHC with \Shake}

\todo{AM: Can you flesh this out}

The build system used to compile GHC, known as Hadrian, has continued development. The use of dynamic dependencies has made the build much easier, and it's now more maintainable. It's now merged into the GHC repo and tested as standard by the CI. It's current state is ... In particular, it takes N minutes to build with \Shake, vs M minutes to build with \Make. The \Shake version has attracted more contributors, and been easier to modify, etc. The code is N lines.

The design we originally outlined remains the one in use. There has been a huge amount of engineering work to make the tests pass (many of the details encoded in the \Make build system were incidental -- but some were essential).

One of the benefits of using Shake is that we have access to high quality profiling information, allowing us to compute critical paths and other metrics (see \cite{mitchell2019ghcrebuildtimes} for a tour of the metrics). This information has shown us that GHC is slow to build (40m on an 8 CPU machine on Windows), that more CPUs would not help (on unlimited CPUs it would take at least 37m), and that a handful of steps (two Haskell compiles, some calls to \hs{configure}) are responsible for a significant amount of that time (at least 10m).

\subsection{Experience from Cloud \Shake}\label{sec-cloud-shake}

Converting \Shake into Cloud \Shake wasn't a difficult process once armed with a roadmap. The key was the introduction of two new functions:

\begin{minted}[xleftmargin=10pt]{haskell}
addCloud :: k -> Ver -> Ver -> [[(k, Hash v)]] -> v -> [FilePath] -> IO ()
lookupCloud :: (k -> m (Maybe (Hash v))) -> k -> Ver -> Ver -> m (Maybe (v, [[k]], IO ()))
\end{minted}

These functions are suspiciously like \hs{recordCT} and \hs{constructCT} from \S\ref{sec-constructive-traces}, with their differences perhaps the most illustrative of the changes required. (We have made some replacements from full \Shake, like replacing \hs{Key} for \hs{k}, to reduce irrelevant differences.)

\begin{itemize}
\item There are two \hs{Ver} arguments being passed to each operation. These are the versions of the build script, and the rule for this particular key. If either version changes then it is as though the key has changed, and nothing will match. These versions are important to avoid using stale build products from previous versions of the build script.
\item The list of dependencies to \hs{addCloud} is a list of lists, rather than a simple list. The reason is that \Shake allows a list of dependencies to be supplied at once, so they can all be built in parallel.
\item The \hs{addCloud} function also takes a list of \hs{FilePath}, being the files that this rule produces -- which must be declared with \hs{produces}, or the output keys from a rule.
\item The \hs{lookupCloud} allows an explicit \hs{Nothing} when looking up a dependent key, since some keys are not buildable.
\item The \hs{lookupCloud} returns at most one result, rather than a list. This change was made for simplicity.
\end{itemize}

The integration of these functions into \Shake is also interesting. We found the most expedient design was to leave \Shake with a verifying trace, but if the verifying trace doesn't work, we use then consult the constructive trace. By bolting constructive traces onto the side of Shake we avoid reengineering of the central database. We haven't found any significant downsides from the bolt-on approach thus far, so it may be a sensible route to go even if developing from scratch -- allowing an optimised verified trace implementation in many cases, and falling back to a more complex implementation only rarely.

The one thing we haven't yet completed on the engineering side is a move to hosting caches over HTTP. At the moment all caches are on shared file systems. This approach can use mounted drives to mirror HTTP connections onto file systems, and reuse tools for managing file systems, share caches with rsync, and is simple. Unfortunately, on certain OS's (e.g. Windows) mounting an HTTP endpoint as a file system requires administrator privileges, so an HTTP cache is still required.

\subsection{Experience from using Cloud \Shake}

While we expected the GHC build system to be the first to take advantage of Cloud \Shake, we were actually beaten to it by Standard Chartered who report\footnote{\url{https://groups.google.com/d/msg/shake-build-system/NbB5kMFS34I/mZ9L4TgkBwAJ}}:

\begin{quote}
Thanks for the symlinks release, we just finished upgrading this build system to use --share. ...
Building from scratch with a warm cache takes around 5 seconds, saving us up to 2 hours. Not bad!
\end{quote}

We have also got the GHC build working with Cloud \Shake, resulting in build times of N minutes instead of M minutes. Due to aspects like \hs{configure} we don't see the dramatic reductions reported by Standard Chartered. Converting to a build suitable for sharing is not overly onerous, but nor is it trivial. Some things that require attention:

\begin{description}
\item[Irrelevant differences] A common problem is that you don't get shared caching when you want it. To get caching, it is important that all machines are identical for the aspects that involve the build system. In particular, that means that all paths must be relative, and all dependencies on system binaries (e.g. \hs{gcc}) should either be controlled by the build system (e.g. using \Nix) or have tolerence to account for minor machine variations.
\item[Insufficient produced files] A build rule must declare which files it produces, so these are stored in the cache and can be restored from the cache. If you don't use a remote cache then it is permissible to have files not known to the build system which change at the same time as files that are known. Once using a remote cache any file that is produced as a side-effect of a rule and then later used \emph{must} be declared. Failure to declare such files means that if some step produces a file, and a later step relies on it, that step breaks. In practice, most issues encountered during the move to Cloud builds for GHC were a lack of declared produced files.
\item[Insufficient dependencies] While insufficient dependencies are often a problem, the move to a Cloud build makes them even more critical, as missing dependencies are likely to mean a result is \emph{never built locally}, rather than just build locally only once. Furthermore, dependencies in a Cloud setting must be more complete. For example, using the build system from Figure \ref{fig-make}, with a local build system without early cutoff, if the rule to produce \hs{main.exe} also made use of \hs{main.c} but didn't declare so, that isn't a problem. With the addition of early cutoff, if \hs{main.c} changes in an important way but \hs{main.o} doesn't update that causes issues, but is a somewhat rare occurance. With Cloud builds that becomes somewhat more common.
\end{description}

To help with the final two issues -- insufficient dependencies and produced files -- we have further enhanced the \Shake lint modes, coupling them to a program called \hs{FSATrace}, which detects which files are read/written by a command line execution. Such information has been very helpful in making the GHC build Cloud ready.
