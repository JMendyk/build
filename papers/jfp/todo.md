# Build Systems à la Carte: Theory and Practice

Extended version of the ICFP 2018 paper "Build Systems à la Carte" to be
submitted to JFP.

## New material

### Tasks (Section 3)

* **Done**: Section 3.8 Examples of Tasks. (A section with examples of
  functorial, applicative and monadic tasks based on Collatz, Fibonacci and
  Ackermann sequences: https://blogs.ncl.ac.uk/andreymokhov/the-task-abstraction/)

* Maybe combine with the `Edit Distance` example from S7.3 Memoization?
  **Andrey**: Decided to keep the Memoization and the corresponding example in Related Work.

### Traces and schedulers (Section 4)

Promote 4.2/4.3 (traces) to top level section Rebuilders.  Elaborate (it's very terse right now) with examples.

Similar Schedulers (current 4.1)

Move 4.4 into the start of 5 (build systems concretely).

* Add Shake's step traces
  * Optimisation
  * Correctness

Explain how to "add constructiveness" to a trace system.  Mabye even concretely:  `constructive :: TraceSystem -> TraceSystem`.Maybe collapse verifying traces and constrctive traces, at least in table 2.  (This would have impact on the structore of the whole trace section.)

### Cloud Shake

* Implemented and released
* Absolute paths and system binaries
* Deferred materialisation. Different invariants for (a) local builds, (b) cloud sharing (you must list all the things you produce), (c) sharing + deferred materialisation (you must declare all the things you consume). Interaction with early cut-off.

### Cloud Hadrian

* Real-life example
* Many examples demonstrating the use of dynamic dependencies

Experience
* Cloud stuff needed tracing infrastructure to expose dependencies.
* Good profiling support (here are pictures) exposes places where we are over-sequential, and over-big tasks (build systems work best with lots of small tasks).
* Ability to compute critical paths
* Numbers: no-op rebuild time; fresh clone rebuild time; (vs clean build).

### Related work

Relationship to SHake paper.   Fully subsumes it, and explains it much better.  Oracles no longer important.

### Engineering section

* Tasks with multiple outputs:
  https://github.com/snowleopard/build/blob/master/src/Build/Multi.hs

* Typed tasks:
  https://github.com/snowleopard/build/blob/master/src/Build/Task/Typed.hs

* Handling failures, see last section here:
  https://blogs.ncl.ac.uk/andreymokhov/the-task-abstraction/

* Self-tracking (?):
  https://github.com/snowleopard/build/blob/master/src/Build/SelfTracking.hs

* Re-using existing infrastructure: (a) key-value store, (b) remote execution service.



## Feedback

### Ulan Degenbaev

How do I do configuration in this framework? Real-life example from Chromium:

https://cs.chromium.org/chromium/src/build/config/v8_target_cpu.gni?rcl=c8f117ce2885070675675564dc39be7e92c6853d&l=38

One could add `Reader conf f` to the `Task` constraints.

Andrey's response: Yes, here is an example, where `Bool` is a configuration type:

```haskell
staticIF :: Bool -> Task Applicative String Int
staticIF b fetch "B1" = Just $ if b then fetch "A1"
                                    else (+) <$> fetch "A2" <*> fetch "A3"
staticIF _ _     _    = Nothing
```

This can be generalised to a `Reader`.

*A much later comment*: Or maybe this is a use case for selective functors?

### Russell O'Connor

https://www.reddit.com/r/haskell/comments/9l2shn/video_build_systems_%C3%A0_la_carte_by_simon_peyton/e750mwb/

The type `Task c k v` is exactly the type of free `c` generated by the
`PStore k v` functor, at `v` where `PStore` is the parametrized store comonad,

```haskell
data PStore i j x = PStore i (j -> x) deriving Functor
```

See: "A Representation Theorem for Second-Order Functionals"
https://arxiv.org/abs/1402.1699

So `Task Applicative k v` is `FreeApplicative (PStore k v) v`. `Task Monad k v`
is `FreeMonad (PStore k v) v`, which a the type of Van Laarhoven free monad,
which is in turn just a different representation of the same class of free
monads that are used in data types à la carte, which I presumed is where the
"à la carte" in the paper's title comes from, though it seems Swierstra isn't
cited so I guess not.

Edit: In particular, this means that `Task Monad k v` is a type of `v`-branching
trees with internal nodes annotated with values of type `k` and whose leaves
hold `v` values. i.e.

```haskell
data TaskMonad k v = Branch k (v -> TaskMonad k v) | Leaf v
```

which is a bit of a peculiar type. I suppose I should study the paper more.

### Karl Palmskog

As I mentioned, there is previous work which formalizes a specific build
language ("CloudMake") in the Dafny verification environment. Dafny is
somewhat similar to Coq, but does not have explicit proofs and much more
built-in automation. Dafny also has a small imperative language, which
is used for CloudMake.

- Dafny tool: https://github.com/Microsoft/dafny
- Dafny source files for CloudMake (part of Dafny test suite):
https://github.com/Microsoft/dafny/tree/master/Test/cloudmake
- The CloudMake formalization paper (subset of pure JavaScript):
https://link.springer.com/chapter/10.1007/978-3-319-06410-9_43
- Paper on practical migration of build scripts to CloudMake:
https://dl.acm.org/citation.cfm?id=2660239

## Random thoughts

### Categorisation of tasks, or what if effect `f` is computation?

Compute Functor = tail recursion
Compute Applicative = primitive recursion
Compute Monad = general recursion

**Andrey:** Not sure now we should go into this.

### ApplicativeZero and MonadZero

These allow to introduce only failures into build systems.

As an interesting build system feature, one might have a build system that
performs a retry when a compute fails -- analogous to travis_retry. I found
an example of similar functionality in Bazel:

--flaky_test_attempts=<a positive integer, the string "default", or
test_regex@attempts. This flag may be passed more than once> multiple uses are
accumulated

Each test will be retried up to the specified number of times in case of any
test failure. Tests that required more than one attempt to pass would be marked
as 'FLAKY' in the test summary. If this option is set, it should specify an int
N or the string 'default'. If it's an int, then all tests will be run up to N
times. If it is not specified or its value is ' default', then only a single
test attempt will be made for regular tests and three for tests marked
explicitly as flaky by their rule (flaky=1 attribute).

See https://docs.bazel.build/versions/master/command-line-reference.html

### MonadZero, MonadPlus, MonadOr

Zero -- for failure.
Or -- for choosing the first success.
Plus -- for picking any success, non-deterministically?

See https://wiki.haskell.org/MonadPlus_reform_proposal

Alternative seems to be similar to MonadOr in that it chooses the first one?
